
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Optimizer</title><meta name="generator" content="MATLAB 9.2"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2017-08-28"><meta name="DC.source" content="Optimizer.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="keyword">classdef</span> Optimizer
    <span class="comment">% Optimizer - class contains only the code that actually optimizes.</span>
    <span class="comment">%</span>

    <span class="keyword">properties</span>
<span class="comment">%         ExxInterp=1;</span>
<span class="comment">%         EyyInterp=1;</span>
<span class="comment">%         thetaInterp=1;</span>
<span class="comment">%         rhoInterp=1;</span>
    <span class="keyword">end</span>

    <span class="keyword">methods</span>
        <span class="comment">% -------------------------------</span>
        <span class="comment">% TOPOOLOGY, SIMP METHOD</span>
        <span class="comment">% -------------------------------</span>
        <span class="keyword">function</span> DV = OptimizeTopology(obj,DV, config, matProp,masterloop)
            DV = DV.CalculateTopologySensitivity(config, matProp, masterloop);
            <span class="comment">% normalize the sensitivies  by dividing by their max values.</span>
            <span class="keyword">if</span> (config.w1 ~= 1) <span class="comment">% if we are using the heat objective</span>
                temp1Max =-1* min(min(DV.sensitivityElastic));
                DV.sensitivityElastic = DV.sensitivityElastic/temp1Max;
                temp2Max = -1* min(min(DV.sensitivityHeat));
                DV.sensitivityHeat = DV.sensitivityHeat/temp2Max;
                DV.dc =1000* (config.w1*DV.sensitivityElastic+config.w2*DV.sensitivityHeat); <span class="comment">% add the two sensitivies together using their weights</span>
            <span class="keyword">else</span>
                DV.dc = config.w1*DV.sensitivityElastic;
            <span class="keyword">end</span>



            <span class="comment">% FILTERING OF SENSITIVITIES</span>
            [DV.dc]   = DV.check( config.nelx, config.nely,config.rmin,DV.x,DV.dc);
            <span class="comment">% DESIGN UPDATE BY THE OPTIMALITY CRITERIA METHOD</span>
            moveLimit=0.1;
            [DV.x]    = OC( config.nelx, config.nely,DV.x,config.totalVolume,DV.dc, DV, config,moveLimit);

            DV.x=DV.ApplyLoadSpecificEmptyRegions(config,DV.x);

        <span class="keyword">end</span>

        <span class="comment">% ----------------------------------</span>
        <span class="comment">% VOLUME FRACTION OPTIMIZATION</span>
        <span class="comment">% ----------------------------------</span>
        <span class="keyword">function</span> DV = OptimizeVolumeFraction(obj,DV,config, matProp, masterloop)
            DV = DV.CalculateMaterialGradientSensitivity(config, matProp, masterloop);

            DV =  DV.CalculateVolumeFractions(config,matProp);

            totalVolLocal = DV.currentVol1Fraction+ DV.currentVol2Fraction;
            fractionCurrent_V1Local = DV.currentVol1Fraction/totalVolLocal;
            targetFraction_v1 = config.v1/(config.v1+config.v2);

            <span class="comment">% Normalize the sensitives.</span>
            <span class="keyword">if</span> (config.w1 ~= 1) <span class="comment">% if we are using the heat objective</span>
                temp1Max = max(max(abs(DV.sensitivityElastic)));
                DV.sensitivityElastic = DV.sensitivityElastic/temp1Max;
                temp2Max = max(max(abs(DV.sensitivityHeat)));
                DV.sensitivityHeat = DV.sensitivityHeat/temp2Max;

                g1 = config.w1*DV.sensitivityElastic+config.w2*DV.sensitivityHeat; <span class="comment">% Calculate the weighted volume fraction change sensitivity.</span>
            <span class="keyword">else</span>
                g1 = config.w1*DV.sensitivityElastic;
            <span class="keyword">end</span>

            <span class="comment">% Filter the g1 sensitivies</span>
            [g1]   = DV.check( config.nelx, config.nely,config.rmin,DV.x,g1);

            <span class="keyword">if</span>(config.volFractionOptiizationMethod==1)
                G1 = g1 - DV.lambda1 +1/(DV.mu1)*( targetFraction_v1-fractionCurrent_V1Local); <span class="comment">% add in the lagrangian</span>
                DV.w = DV.w+config.timestep*G1; <span class="comment">% update the volume fraction.</span>
                DV.w = max(min( DV.w,1),0);    <span class="comment">% Don't allow the    vol fraction to go above 1 or below 0</span>
                DV.lambda1 =  DV.lambda1 -1/(DV.mu1)*(targetFraction_v1-fractionCurrent_V1Local)*config.volFractionDamping;
<span class="comment">%                 DV.lambda1</span>
            <span class="keyword">else</span>
                largest=1e9;
                l1 = 0; l2 = largest;<span class="comment">% move = 0.2;</span>
                <span class="comment">%             sumDensity =0;</span>
                totalMaterial = sum(sum(DV.x));
                wProposed = DV.w;
                g1Max = max(max(g1));
                g1Min = min(min(g1));
                <span class="comment">%                 if(g1Max&gt;0)</span>
                <span class="comment">%                 g1=g1-g1Max;</span>
                <span class="comment">%                 end</span>
                <span class="keyword">if</span>(g1Min&lt;0)
                    g1 = -g1Min+g1;
                <span class="keyword">end</span>
                moveLimit = 0.1;

                targetRatioMethod =1;


                   targetRatio = config.v1/config.v2;

                <span class="keyword">while</span> (l2-l1 &gt; 1e-4)
                    lambda1 = 0.5*(l2+l1);
                    <span class="comment">%                     wProposed=min(max(max(0,min(1,DV.w.*(sqrt(-g1Min+g1/lambda1)))),DV.w-moveLimit),DV.w+moveLimit);</span>
                    wProposed=min(max(max(0,min(1,DV.w.*(sqrt(g1/lambda1)))),DV.w-moveLimit),DV.w+moveLimit);

                    <span class="comment">%                   totalMat1 =sum(sum( DV.x.*DV.w*matProp.E_material1));</span>
                    <span class="comment">%                 totalMat2 =sum(sum( DV.x.*(1-DV.w)*matProp.E_material2));</span>
                    <span class="comment">% obj.actualAverageE= obj.currentVol1Fraction*matProp.E_material1+  obj. currentVol2Fraction*matProp.E_material2;</span>
                    <span class="comment">%                 obj.actualAverageE= (totalMat1+totalMat2)/totalMaterial;</span>

                    <span class="comment">%                 obj.   currentVol2Fraction =sum(sum( obj.x.*(1-obj.w)))/ne;</span>
                    <span class="comment">%                     fractionCurrent_V1Local = currentVol1Fraction/totalVolLocal;</span>


                    <span class="keyword">if</span>(1==0)
                         currentVol1Fraction =sum(sum( DV.x.*wProposed))/totalMaterial;
                        <span class="keyword">if</span>(targetRatioMethod==1)
                             <span class="comment">% ------------------------</span>
                            <span class="comment">% Target ratio v1/(v1+v2))</span>
                            <span class="comment">% ------------------------</span>

                            <span class="keyword">if</span> targetFraction_v1- currentVol1Fraction&lt;0
                                l1 = lambda1;
                            <span class="keyword">else</span>
                                l2 = lambda1;
                            <span class="keyword">end</span>
                        <span class="keyword">elseif</span>(  targetRatioMethod==2)
                             <span class="comment">% ------------------------</span>
                            <span class="comment">% Target ratio v1/v2</span>
                            <span class="comment">% ------------------------</span>

                            currentV1 = sum(sum( DV.x.*wProposed));
                            currentV2 = sum(sum((DV.x).*(1-wProposed)));
                            currentRatio = currentV1/currentV2;
                             <span class="keyword">if</span> 100*targetRatio- 100*currentRatio&lt;0;
                                l1 = lambda1;
                                <span class="comment">%                          l2 = lambda1;</span>
                            <span class="keyword">else</span>
                                l2 = lambda1;
                                <span class="comment">%                          l1 = lambda1;</span>
                             <span class="keyword">end</span>

                        <span class="keyword">elseif</span>(  targetRatioMethod==3)

                            <span class="comment">% ------------------------</span>
                            <span class="comment">% Target v1 only</span>
                            <span class="comment">% ------------------------</span>
<span class="comment">%                               totalMaterial = sum(sum(DV.x));</span>

                            currentV1 = sum(sum( DV.x.*wProposed));

                            v1RatioToTotal=currentV1/(config.nelx*config.nely);

                            targetRatio=   config.v1;

                             <span class="keyword">if</span> targetRatio- v1RatioToTotal&lt;0;
                                l1 = lambda1;
                                <span class="comment">%                          l2 = lambda1;</span>
                            <span class="keyword">else</span>
                                l2 = lambda1;
                                <span class="comment">%                          l1 = lambda1;</span>
                             <span class="keyword">end</span>

                        <span class="keyword">end</span>



                    <span class="keyword">else</span>
                        <span class="comment">% ------------------------</span>
                        <span class="comment">% Target an Elastic Modulus</span>
                        <span class="comment">% ------------------------</span>
                        totalMat1 =sum(sum( DV.x.*wProposed*matProp.E_material1));
                        totalMat2 =sum(sum( DV.x.*(1-wProposed)*matProp.E_material2));
                        <span class="comment">% obj.actualAverageE= obj.currentVol1Fraction*matProp.E_material1+  obj. currentVol2Fraction*matProp.E_material2;</span>
                        averageElasticLocal= (totalMat1+totalMat2)/totalMaterial;
                        <span class="comment">%               averageElasticLocal = (sum(sum(EyyNew.*Xtemp))+sum(sum(ExxNew.*Xtemp)))/neSolid;</span>
                        <span class="comment">%               averageElasticLocal=averageElasticLocal/2; % Becuse Eyy and Exx are from one element, so to get the average divide by 2</span>
                        E_target=config.targetAvgExxEyy;
                        <span class="keyword">if</span> E_target- averageElasticLocal&lt;0
                            l1 = lambda1;
                        <span class="keyword">else</span>
                            l2 = lambda1;
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                DV.w=wProposed;
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">% ----------------------------------</span>
        <span class="comment">% ORTHO DISTRIBUTION OPTIMIZATION</span>
        <span class="comment">% ----------------------------------</span>
        <span class="comment">%         function [] = OptimizeOrthoDistribution(obj,DV,config, matProp, masterloop)</span>
        <span class="comment">%             DV = DV.CalculateOthogonalDistributionSensitivity(config, matProp, masterloop);</span>
        <span class="comment">%             DV.sensitivityElastic = check( config.nelx, config.nely,config.rmin,DV.x,DV.sensitivityElastic);</span>
        <span class="comment">%             % move= 0.1* 20/(20+masterloop);</span>
        <span class="comment">%             move = config.orthDistMoveLimit;</span>
        <span class="comment">%             config.orthDistMoveLimit= config.orthDistMoveLimit* 10/(10+masterloop);</span>
        <span class="comment">%             %-----------------------</span>
        <span class="comment">%             %</span>
        <span class="comment">%             % Update design var.</span>
        <span class="comment">%             %-----------------------</span>
        <span class="comment">%             for ely = 1:config.nely</span>
        <span class="comment">%                 for elx = 1:config.nelx</span>
        <span class="comment">%                     if(DV.sensitivityElastic(ely,elx)&lt;0.05)</span>
        <span class="comment">%                         DV.d(ely,elx) =  max(  DV.d(ely,elx)-move,config.minDorth);</span>
        <span class="comment">%                     end</span>
        <span class="comment">%</span>
        <span class="comment">%                     if(DV.sensitivityElastic(ely,elx)&gt;0.05)</span>
        <span class="comment">%                         DV.d(ely,elx) =  min(  DV.d(ely,elx)+ move,config.maxDorth);</span>
        <span class="comment">%                     end</span>
        <span class="comment">%</span>
        <span class="comment">%                 end</span>
        <span class="comment">%             end</span>
        <span class="comment">%         end</span>

        <span class="comment">% ----------------------------------</span>
        <span class="comment">% ROTATION OPTIMIZATION</span>
        <span class="comment">% ----------------------------------</span>
        <span class="keyword">function</span> DV = OptimizeRotation(obj,DV,config, matProp, masterloop)
            <span class="comment">%                 move= 0.1* 20/(20+masterloop);</span>
            <span class="comment">% allow multiple loading cases.</span>
            [~, t2] = size(config.loadingCase);

            epsilon = pi/180; <span class="comment">% 1 DEGREES ACCURACY</span>
            elementsInRow = config.nelx+1;

            <span class="keyword">for</span> ely = 1:config.nely
                rowMultiplier = ely-1;
                <span class="keyword">for</span> elx = 1:config.nelx
                    rhoSIMP =  DV.x(ely,elx);
                    <span class="keyword">if</span>(rhoSIMP&gt;config.noNewMesoDesignDensityCutOff)

                        <span class="comment">% -------------------</span>
                        <span class="comment">% STEP 1, GET THE DISPLACEMENT FOR THIS NODE</span>
                        <span class="comment">% -------------------</span>
                        nodes1=[rowMultiplier*elementsInRow+elx;
                            rowMultiplier*elementsInRow+elx+1;
                            (rowMultiplier +1)*elementsInRow+elx+1;
                            (rowMultiplier +1)*elementsInRow+elx];

                        xNodes = nodes1*2-1;
                        yNodes = nodes1*2;
                        NodeNumbers = [xNodes(1) yNodes(1) xNodes(2) yNodes(2) xNodes(3) yNodes(3) xNodes(4) yNodes(4)];
                        UallCaseForElement = DV.U(1:t2,NodeNumbers);
                        U = UallCaseForElement;

                        <span class="comment">% -------------------</span>
                        <span class="comment">% STEP 2, SET UP GOLDEN RATIO METHOD TO FIND</span>
                        <span class="comment">% OPTIMAL THETA FOR ROTATION</span>
                        <span class="comment">% -------------------</span>

                        n = 0;
                        x0 = config.minRotation; <span class="comment">%lower_bracket;</span>
                        x3 = config.maxRotation;<span class="comment">% higher_bracket;</span>
                        leng = x3-x0;
                        grleng = leng*config.gr ; <span class="comment">% golden ratio lenth</span>
                        x1 = x3 - grleng;
                        x2 = x0 + grleng;
                        rhoSIMP =  DV.x(ely,elx);
                        mat1Frac  =[];<span class="comment">% DV.w(ely,elx);</span>
                        Exx = DV.Exx(ely,elx);
                        Eyy = DV.Eyy(ely,elx);

                        thetaSubSystem = DV.thetaSub(ely,elx);
                        penaltyValue=DV.penaltyTheta(ely,elx);
                        lagraMultiplier=DV.lambdaTheta(ely,elx);

                        <span class="comment">%                         orthD = DV.d(ely,elx);</span>
                        <span class="comment">%fx1 = obj.EvaluteARotation(U,rhoSIMP, mat1Frac,Exx,Eyy,x1,thetaSubSystem,penaltyValue,lagraMultiplier,matProp, config,DV.maxElemStraniEnergy);</span>


                        fx1= obj.EvaluteARotation(U,rhoSIMP, mat1Frac,Exx,Eyy,x1,thetaSubSystem,penaltyValue,lagraMultiplier,matProp, config,DV.maxElemStraniEnergy);
                        fx2 = obj.EvaluteARotation(U,rhoSIMP, mat1Frac,Exx,Eyy,x2,thetaSubSystem,penaltyValue,lagraMultiplier,matProp, config,DV.maxElemStraniEnergy);

                        <span class="comment">%                         if(masterloop&gt;5)</span>
                        <span class="comment">%                             debug = 1;</span>
                        <span class="comment">%                         else</span>
                        debug=0;
                        <span class="comment">%                         end</span>
                        verbosity = 0;

                        <span class="keyword">if</span>(   debug == 1)
                            xtemp = x0:pi/180:x3;
                            ytemp = zeros(1, size(xtemp,2));
                            count = 1;
                            <span class="keyword">for</span> thetaTemp = xtemp
                                ytemp(count)= obj.EvaluteARotation(U,rhoSIMP, mat1Frac,Exx,Eyy,thetaTemp,thetaSubSystem,penaltyValue,lagraMultiplier,matProp, config,DV.maxElemStraniEnergy);
                                count = count+1;
                            <span class="keyword">end</span>
                            figure(2)
                            subSysXvalus = [x0 DV.thetaSub(ely,elx) x3];
                            subSysYvalus = [min(ytemp) max(ytemp) max(ytemp)];
                            plot(xtemp,ytemp);
                            hold <span class="string">on</span>
                            stairs(subSysXvalus,subSysYvalus)
                            hold <span class="string">off</span>
                            title(sprintf(<span class="string">'Lagrangian Function for Element x = %i, y = %i'</span>,elx,ely));
                            nothin = 1;
                        <span class="keyword">end</span>


                        <span class="keyword">while</span>(1 == 1)
                            <span class="keyword">if</span>(debug == 1 &amp;&amp; verbosity ==1)
                                str = sprintf(<span class="string">'loop# = %d, x0 = %f, x1 = %f, x2 = %f, x3 = %f, fx1 = %f, fx2 = %f\n'</span>, n, x0, x1, x2, x3, fx1, fx2); display(str);
                            <span class="keyword">end</span>

                            <span class="keyword">if</span>(fx1&lt;=fx2) <span class="comment">% less than or equal</span>
                                <span class="comment">% x0 = x0; % x0 stays the same</span>
                                x3 = x2; <span class="comment">% the old x2 is now x3</span>
                                x2 = x1; <span class="comment">% the old x1 is now x2</span>
                                fx2 = fx1;
                                leng = x3 - x0; <span class="comment">% find the length of the interval</span>
                                x1 = x3 - leng*config.gr; <span class="comment">% find golden ratio of length, subtract it from the x3 value</span>
                                fx1 = obj.EvaluteARotation(U,rhoSIMP, mat1Frac,Exx,Eyy,x1,thetaSubSystem,penaltyValue,lagraMultiplier,matProp, config,DV.maxElemStraniEnergy);<span class="comment">% calculate the fx</span>

                            <span class="keyword">elseif</span>(fx1&gt;fx2) <span class="comment">% greater than</span>
                                x0 = x1; <span class="comment">% the old x1 is now x0</span>
                                x1 = x2; <span class="comment">% the old x2 is now the new x1</span>
                                fx1 = fx2;
                                <span class="comment">% x3 = x3; % x3 stays the same.</span>

                                leng = (x3 - x0); <span class="comment">% find the length of the interval</span>
                                x2 = x0 + leng*config.gr; <span class="comment">% find golden ratio of length, subtract it from the x3 value</span>
                                fx2 = obj.EvaluteARotation(U,rhoSIMP, mat1Frac,Exx,Eyy,x2,thetaSubSystem,penaltyValue,lagraMultiplier,matProp, config,DV.maxElemStraniEnergy);  <span class="comment">% calculate the fx</span>
                            <span class="keyword">end</span>

                            <span class="comment">% check to see if we are as close as we want</span>
                            <span class="keyword">if</span>(leng &lt; epsilon || n&gt;100)
                                <span class="keyword">break</span>;
                            <span class="keyword">end</span>
                            n = n +1; <span class="comment">% increment</span>

                        <span class="keyword">end</span>

                        <span class="comment">% -------------------</span>
                        <span class="comment">% STEP 3, RECORD THE OPTIMAL THETA</span>
                        <span class="comment">% -------------------</span>
                        minTvalue = (x2 + x3)/2;
                        moveLimit = config.rotationMoveLimit;

                        <span class="comment">% max move limit =  half the diff to optimal</span>
                        diffT = abs(minTvalue-DV.t(ely,elx));
                        moveLimit=min(moveLimit,diffT*0.1);

                        tOld = DV.t(ely,elx);
                        <span class="keyword">if</span>(minTvalue&gt;DV.t(ely,elx)+moveLimit)
                            DV.t(ely,elx)= DV.t(ely,elx)+moveLimit;
                        <span class="keyword">elseif</span>(minTvalue&lt;DV.t(ely,elx)-moveLimit)
                            DV.t(ely,elx)= DV.t(ely,elx)-moveLimit;
                        <span class="keyword">else</span>
                            DV.t(ely,elx)=minTvalue;
                        <span class="keyword">end</span>

                        <span class="comment">% Damp the changes</span>
                        <span class="keyword">if</span>(tOld&gt;0 &amp;&amp;   DV.t(ely,elx) &gt;0)
                            DV.t(ely,elx) = tOld*sqrt( DV.t(ely,elx)/tOld);
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">% ---------------------------</span>
        <span class="comment">% EVALUTE THE OBJECTIVE FUNCTION FOR A ROTATION</span>
        <span class="comment">%----------------------------</span>
        <span class="keyword">function</span> lagrangianValue = EvaluteARotation(~,U,topDensity, material1Fraction,Exx,Eyy,thetaSys,thetaSubSystem,penaltyValue,lagraMultiplier,matProp, config,maxElemStraniEnergy)
            K = matProp.getKMatrixTopExxYyyRotVars(config,topDensity,Exx, Eyy,thetaSys,material1Fraction, 1, 1);
            <span class="comment">% LOOP OVER LOADING CASES.</span>
            <span class="comment">% U'S ROWS ARE UNIQUE LOADING CASES</span>
            <span class="comment">% EACH ROW CONTAINS 8 VALUES FOR THE 8 DOF OF THE ELEMENT</span>
            <span class="comment">% allow multiple loading cases.</span>
            [~, t2] = size(config.loadingCase);
            term1=0;
            <span class="keyword">for</span> i = 1:t2
                Ucase = U(i,:)';
                term1= term1+Ucase'*K*Ucase;
            <span class="keyword">end</span>
            term1=-term1;
            <span class="comment">%             term1=-term1/maxElemStraniEnergy;</span>

            <span class="comment">%             term2 = penaltyValue/2*(thetaSys-thetaSubSystem)^2;</span>
            <span class="comment">%             term2 = penaltyValue*(thetaSys-thetaSubSystem)^2;</span>
            term2 = penaltyValue*abs(thetaSys-thetaSubSystem);
            <span class="comment">%             term3 = lagraMultiplier*(thetaSys-thetaSubSystem);</span>
            <span class="comment">%             lagrangianValue=term1+term2+term3;</span>
            <span class="comment">%             normalizer=penaltyValue/2*(pi/4)^2;</span>
            <span class="comment">%                term2=term2/normalizer;</span>

            <span class="comment">%                lagrangianValue=term1+term2+term3;</span>
            lagrangianValue=term1+term2;


        <span class="keyword">end</span>


        <span class="comment">% ----------------------------------</span>
        <span class="comment">% E_xx and E_yy  OPTIMIZATION</span>
        <span class="comment">% ----------------------------------</span>
        <span class="keyword">function</span> [DV] = OptimizeExxEyy(obj,DV,config, matProp, masterloop)
            <span class="comment">%             if(config.useTargetMesoDensity==1)</span>
            DV= OptimizeExxEyy_V3(obj,DV,config, matProp, masterloop);
            <span class="comment">%             else</span>
            <span class="comment">%                 DV= OptimizeExxEyy_V2(obj,DV,config, matProp, masterloop);</span>
            <span class="comment">%             end</span>
        <span class="keyword">end</span>


        <span class="comment">% ----------------------------------</span>
        <span class="comment">% E_xx and E_yy  OPTIMIZATION</span>
        <span class="comment">%</span>
        <span class="comment">%   Version 3</span>
        <span class="comment">% TARGET AVG MESO DENSITY AS CONSTRAINT.</span>
        <span class="comment">% ----------------------------------</span>
        <span class="keyword">function</span> [DV] = OptimizeExxEyy_V3(obj,DV,config, matProp, masterloop)
            DV = DV.CalculateExxEyySensitivity(config, matProp, masterloop);
            DV.sensitivityElastic = DV.check( config.nelx, config.nely,config.rminExxEyy,DV.x,DV.sensitivityElastic);
            DV.sensitivityElasticPart2 = DV.check( config.nelx, config.nely,config.rminExxEyy,DV.x,DV.sensitivityElasticPart2);


            testingIsoTropicRecution=1;
            <span class="keyword">if</span>(testingIsoTropicRecution==1)
                combinedSensitivity = DV.sensitivityElastic+ DV.sensitivityElasticPart2;
                 DV.sensitivityElasticPart2=combinedSensitivity;
                 DV.sensitivityElastic=combinedSensitivity;
            <span class="keyword">end</span>

            <span class="comment">% if(config.macro_meso_iteration&gt;=2 &amp;&amp; mod(masterloop,3)==1)</span>
            <span class="keyword">if</span>(config.macro_meso_iteration&gt;=2 )
                deltaT=0.2;
                diffExx = DV.ExxSub-DV.Exx;
                diffEyy = DV.EyySub-DV.Eyy  ;
                <span class="comment">%</span>
                DV.lambdaExx=max( min(DV.lambdaExx+deltaT *diffExx,matProp.E_material1),-matProp.E_material1);
                DV.lambdaEyy= max( min( DV.lambdaEyy+deltaT*diffEyy,matProp.E_material1),-matProp.E_material1);
                <span class="comment">%  DV.lambdaExx=DV.lambdaExx+deltaT *diffExx;</span>
                <span class="comment">%   DV.lambdaEyy= DV.lambdaEyy+deltaT*diffEyy;</span>
                disp(<span class="string">'Updated Lambda Values Exx Eyy'</span>)
            <span class="keyword">end</span>


            <span class="comment">%-----------------------</span>
            <span class="comment">%</span>
            <span class="comment">% Update design var.</span>
            <span class="comment">%-----------------------</span>
            largest=1e9;

            move = matProp.E_material1*0.05;
            minimum =config.minEallowed;

            <span class="comment">% ----------------</span>
            <span class="comment">% Exx</span>
            <span class="comment">% ----------------</span>
            ExxNew = DV.Exx;
            EyyNew = DV.Eyy;

            totalMaterial = sum(sum(DV.x));

            term1Exx = DV.sensitivityElastic;
            term1Eyy= DV.sensitivityElasticPart2;

            smallestLambdExx = min(min(DV.lambdaExx));
            smallestLambdEyy = min(min(DV.lambdaEyy));
            smallestOfTwo = min(smallestLambdExx,smallestLambdEyy)-1;

            term2Exx =( DV.lambdaExx-smallestOfTwo).*DV.penaltyExx;
            term2Eyy = (DV.lambdaEyy-smallestOfTwo).*DV.penaltyEyy;

            w1 = 1;
            w2 = 0;
            <span class="comment">%    if( config.macro_meso_iteration&gt;=2 ) % Weight toward satifying consistency constraint.</span>
            <span class="comment">%    w2=min( ( config.macro_meso_iteration-2)*0.2,1); % staring iteration 3, start relaxing the meso density constraint.</span>
            <span class="comment">%      w1 = 1-w2;</span>
            <span class="comment">%     end</span>

            theta = DV.t;

            <span class="comment">% ---------------------------------------------------</span>
            <span class="comment">%</span>
            <span class="comment">% TARGET AVG MESO DENSITY AS CONSTRAINT.</span>
            <span class="comment">% Update 3 (idea)</span>
            <span class="comment">%</span>
            <span class="comment">% ---------------------------------------------------</span>
            l1 = 0; l2 = largest;<span class="comment">% move = 0.2;</span>
            sumDensity =0;
            <span class="keyword">while</span> (l2-l1 &gt; 1e-5)
                lambda1 = 0.5*(l2+l1);

                <span class="keyword">if</span>(config.useTargetMesoDensity==1)
                    ExxInput =ExxNew/matProp.E_material1; <span class="comment">% % MOVED to the function scale down by the simp density, since the actual rho is a function of what is SIMP density and Exx or Eyy</span>
                    EyyInput = EyyNew/matProp.E_material1;
                    [dDensityEyy, dDensityExx,~] = obj.CalculateDensitySensitivityandRho(ExxInput,EyyInput,theta,DV.x,DV.ResponseSurfaceCoefficents,config,matProp,DV.densityOffsetArray);

                    dDensityEyy = DV.check( config.nelx, config.nely,config.rminExxEyy,DV.x,dDensityEyy);
                    dDensityExx = DV.check( config.nelx, config.nely,config.rminExxEyy,DV.x,dDensityExx);
                <span class="keyword">else</span>
                    dDensityExx=ones(size(term1Exx));
                    dDensityEyy=ones(size(term1Exx));
                <span class="keyword">end</span>




                combinedTermsExx=(term1Exx+term2Exx)./(lambda1*dDensityExx);
                combinedTermsEyy=(term1Eyy+term2Eyy)./(lambda1*dDensityEyy);

                <span class="comment">%                 targetExx = ExxNew.*combinedTermsExx;</span>
                <span class="comment">%                 targetEyy = EyyNew.*combinedTermsEyy;</span>
                targetExx = DV.Exx.*combinedTermsExx;
                targetEyy = DV.Eyy.*combinedTermsEyy;
                ExxNew = max(0.1,max( minimum - EyyNew,  max(DV.Exx-move ,  min(  min(targetExx,DV.Exx+move ),matProp.E_material1))));
                EyyNew = max(0.1,max(minimum -  ExxNew,  max(DV.Eyy-move ,  min(  min(targetEyy,DV.Eyy+move ),matProp.E_material1))));
                <span class="comment">%                  logicTest1 = mesoDensity&lt;config.minMesoDensityInOptimizer;</span>
                <span class="comment">%                   logicTest2 =DV.x&gt;config.voidMaterialDensityCutOff;</span>
                <span class="comment">%                  logicTest=(logicTest1+logicTest2)&gt;1.1;</span>
                <span class="comment">%                  minE_allowed = ones(size(targetExx));</span>
                <span class="comment">%                  minE_allowed(logicTest)=ExxNew(logicTest);</span>
                <span class="comment">%                  ExxNew = max(minE_allowed,max( minimum - EyyNew,  max(DV.Exx-move ,  min(  min(targetExx,DV.Exx+move ),matProp.E_material1))));</span>
                <span class="comment">%</span>
                <span class="comment">%                   minE_allowed(logicTest)=EyyNew(logicTest);</span>
                <span class="comment">%                 EyyNew = max(minE_allowed,max(minimum -  ExxNew,  max(DV.Eyy-move ,  min(  min(targetEyy,DV.Eyy+move ),matProp.E_material1))));</span>

                <span class="comment">%                 sumDensity = sumDensity/(config.nelx*config.nely*config.totalVolume);</span>
                ExxSysAndSubDiffSummed=sum(sum(abs(DV.x.*(ExxNew-DV.ExxSub)))); <span class="comment">%</span>
                EyySysAndSubDiffSummed=sum(sum(abs(DV.x.*(EyyNew-DV.EyySub))));<span class="comment">%</span>
                ConsistConstraintMag = ExxSysAndSubDiffSummed+EyySysAndSubDiffSummed;
                <span class="comment">%                 ConsistConstraintMag=-ConsistConstraintMag;</span>
                ConsistConstraintMag = ConsistConstraintMag/(matProp.E_material1*totalMaterial);

                <span class="keyword">if</span>(config.useTargetMesoDensity==1)
                    [~, ~,rhoValue] = obj.CalculateDensitySensitivityandRho(ExxNew/matProp.E_material1,EyyNew/matProp.E_material1,theta,DV.x,DV.ResponseSurfaceCoefficents,config,matProp,DV.densityOffsetArray);
                    rhoValue=max(0,min(rhoValue,1));
                    temp2 = sum(sum(rhoValue));
                    sumDensity=temp2/(config.nelx*config.nely*config.totalVolume);

                    <span class="comment">% Determine if the consistency constraint is being under</span>
                    <span class="comment">% valued</span>


                    terms= w1*(config.targetExxEyyDensity- sumDensity)+w2*(ConsistConstraintMag);
                    <span class="keyword">if</span> (terms)&lt;0
                        l1 = lambda1;
                    <span class="keyword">else</span>
                        l2 = lambda1;
                    <span class="keyword">end</span>

                <span class="keyword">else</span>
                    totalExx =DV.x.*ExxNew;
                    totalEyy = DV.x.* EyyNew;
                    avgE = (totalExx+totalEyy)/2;
                    averageElasticLocal= sum(sum(avgE))/totalMaterial;
                    <span class="comment">%               averageElasticLocal = (sum(sum(EyyNew.*Xtemp))+sum(sum(ExxNew.*Xtemp)))/neSolid;</span>
                    <span class="comment">%               averageElasticLocal=averageElasticLocal/2; % Becuse Eyy and Exx are from one element, so to get the average divide by 2</span>
                    E_target=config.targetAvgExxEyy;
                    <span class="keyword">if</span> E_target- averageElasticLocal&lt;0;
                        l1 = lambda1;
                    <span class="keyword">else</span>
                        l2 = lambda1;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            multiplier= 10000;
            text1 =    sprintf(<span class="string">'\nExxNew\t\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f'</span>,ExxNew(1,1) ,ExxNew(5,1),ExxNew(5,5));
            text2 =    sprintf(<span class="string">'ExxSub\t\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f'</span>,DV.ExxSub(1,1),DV.ExxSub(5,1),DV.ExxSub(5,5));
            text3=    sprintf(<span class="string">'Exx\\t\t\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f'</span>,DV.Exx(1,1),DV.Exx(5,1),DV.Exx(5,5));
            text4 =    sprintf(<span class="string">'DiffXXNew \t\t\t\t[1,1   5,1      5,5],  %f ,%f %f'</span>,ExxNew(1,1) - DV.ExxSub(1,1),ExxNew(5,1) - DV.ExxSub(5,1),ExxNew(5,5) - DV.ExxSub(5,5));
            text5 =    sprintf(<span class="string">'combinedTermsExx\t\t[1,1   5,1      5,5],  %f ,%f %f'</span>,combinedTermsExx(1,1),combinedTermsExx(5,1),combinedTermsExx(5,5));
            text6 =    sprintf(<span class="string">'penaltyExx*10000\t\t[1,1   5,1      5,5],  %f ,%f %f'</span>,DV.penaltyExx(1,1)*multiplier,DV.penaltyExx(5,1)*multiplier,DV.penaltyExx(5,5)*multiplier);
            text7 =    sprintf(<span class="string">'lambdaExx\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f'</span>,DV.lambdaExx(1,1),DV.lambdaExx(5,1),DV.lambdaExx(5,5));
            text75 =    sprintf(<span class="string">'dDensityExx\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f'</span>,dDensityExx(1,1),dDensityExx(5,1),dDensityExx(5,5));
            text8 =    sprintf(<span class="string">'lambda1 and density\t\t[  %f ,%f'</span>,lambda1,sumDensity);
            text9 =    sprintf(<span class="string">'ConsistConstraintMag and w2 \t\t[  %f ,%f\n'</span>,ConsistConstraintMag,w2);

            disp(text1)
            disp(text2)
            disp(text3)
            disp(text4)
            disp(text5)
            disp(text6)
            disp(text7)
            disp(text75)
            disp(text8)
            disp(text9)


            debug = 0;
            <span class="keyword">if</span>(debug ==1)
                figure(2)
                p = plotResults;
                xplots=3;
                yplots =3;
                plotNum=1;

                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(dDensityEyy,<span class="string">'dDensityEyy'</span>);
                plotNum=plotNum+1;

                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(dDensityExx,<span class="string">'dDensityExx'</span>);
                plotNum=plotNum+1;

                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(numeratorExx,<span class="string">'completeExx'</span>);
                plotNum=plotNum+1;

                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(numeratorEyy,<span class="string">'completeEyy'</span>);
                plotNum=plotNum+1;

                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(combinedTermsExx/lmid,<span class="string">'combinedTermsExx/lmid'</span>);
                plotNum=plotNum+1;

                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(combinedTermsEyy/lmid,<span class="string">'combinedTermsEyy/lmid'</span>);
                plotNum=plotNum+1;

                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(DV.t-DV.thetaSub,<span class="string">'theta diff'</span>);
                plotNum=plotNum+1;

                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(DV.Eyy - DV.EyySub,<span class="string">'Eyy diff'</span>);
                plotNum=plotNum+1;

                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(DV.Exx-DV.ExxSub,<span class="string">'Exx diff'</span>);
                plotNum=plotNum+1;
            <span class="keyword">end</span>

            <span class="comment">% -----------------------</span>
            <span class="comment">% Set the valeus.</span>
            <span class="comment">% -----------------------</span>
            DV.Exx =DV.Exx.*sqrt( ExxNew./  DV.Exx);
            DV.Eyy = DV.Eyy.*sqrt( EyyNew./  DV.Eyy );

             <span class="keyword">if</span>(testingIsoTropicRecution==1)
                  E_combined =( DV.Exx+DV.Eyy)./2;
                    DV.Exx =E_combined;
                    DV.Eyy =E_combined;
             <span class="keyword">end</span>


        <span class="keyword">end</span>


        <span class="keyword">function</span> [DV] =FindStartingExxEyy_V3(obj,DV,config, matProp, masterloop)
            <span class="comment">% --------------------</span>
            <span class="comment">%</span>
            <span class="comment">%   SCALE starting Exx Eyy values</span>
            <span class="comment">%</span>
            <span class="comment">% --------------------</span>
            <span class="keyword">if</span>(config.macro_meso_iteration==1 )
                <span class="keyword">if</span> (49&lt;config.mode &amp;&amp; config.mode &lt;100  )
                    l1 = 0; l2 = 100000;<span class="comment">% move = 0.2;</span>
                    <span class="comment">%             sumDensity =0;</span>
                    o=Optimizer;
                    <span class="keyword">if</span>(config.useTargetMesoDensity==1)
                        target=config.targetExxEyyDensity;
                        theta=DV.t;
                    <span class="keyword">else</span>
                        target=config.targetAvgExxEyy;
                        totalMaterial= sum(sum(DV.x));
                    <span class="keyword">end</span>

                    fprintf(<span class="string">'try scaling the starting values\n'</span>);

                    <span class="keyword">while</span> (l2-l1 &gt; 1e-6)
                        lambda1 = 0.5*(l2+l1);
                        ExxNew=DV.Exx*lambda1;
                        EyyNew=DV.Eyy*lambda1;

                        <span class="keyword">if</span>(config.useTargetMesoDensity==1)
                            [~, ~,rhoValue] = o.CalculateDensitySensitivityandRho(ExxNew/matProp.E_material1,EyyNew/matProp.E_material1,theta,DV.x,DV.ResponseSurfaceCoefficents,config,matProp,0);
                            rhoValue=max(0,min(rhoValue,1));
                            temp2 = sum(sum(rhoValue));
                            sumDensity=temp2/(config.nelx*config.nely*config.totalVolume);
                            currentValue=sumDensity;
                        <span class="keyword">else</span>


                            totalExx =DV.x.*ExxNew;
                            totalEyy = DV.x.* EyyNew;
                            avgE = (totalExx+totalEyy)/2;
                            averageElasticLocal= sum(sum(avgE))/totalMaterial;

                            currentValue=averageElasticLocal;
                        <span class="keyword">end</span>


                        fprintf(<span class="string">'Target %f and current %f\n'</span>,target,currentValue);
                        <span class="keyword">if</span> target- currentValue&lt;0;
                            l2 = lambda1;
                        <span class="keyword">else</span>
                            l1 = lambda1;
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>

                    DV.Exx=    DV.Exx*lambda1;
                    DV.Eyy=      DV.Eyy*lambda1;

                    fprintf(<span class="string">'Final Lambda = %f with final value of %f\n'</span>,lambda1,currentValue);
                <span class="keyword">end</span>
            <span class="keyword">end</span>

        <span class="keyword">end</span>

        <span class="comment">% -------------------------------------</span>
        <span class="comment">% Calculate the density and sensitivity of the Exx,Eyy,theta</span>
        <span class="comment">% values.</span>
        <span class="comment">%</span>
        <span class="comment">% USe a response surface, ANN, or interpolation depending on</span>
        <span class="comment">% settings.</span>
        <span class="comment">% -------------------------------------</span>
        <span class="keyword">function</span> [EyySensitivty, ExxSensitivity,rhoValue] = CalculateDensitySensitivityandRho(obj,Exx,Eyy,theta,xSimp,Coefficents,config,matProp,OffSet)

            [EyySensitivty, ExxSensitivity,rhoValue] = CalculateDensitySensitivityandRho_OLD(obj,Exx,Eyy,theta,xSimp,Coefficents,config,matProp);
            <span class="comment">%               rhoValue=max(config.MesoMinimumDensity,min(rhoValue,1));</span>
            rhoValue=rhoValue+OffSet;
        <span class="keyword">end</span>

        <span class="keyword">function</span> [EyySensitivty, ExxSensitivity,rhoValue] = CalculateDensitySensitivityandRho_OLD(obj,Exx,Eyy,theta,xSimp, Coefficents,config,matProp)
            co = Coefficents;



            Exx=Exx.*(xSimp.^config.penal);
            Eyy=Eyy.*(xSimp.^config.penal);

            ExxOriginal = Exx;
            EyyOriginal= Eyy;
            thetaOriginal = theta;

            <span class="keyword">if</span>(config.useANN==1)

                <span class="comment">% Make the inputs be so taht Exx &gt; Eyy</span>
                <span class="comment">% Rather than a strict theta, use the distance from pi/4, since the problem</span>
                <span class="comment">% is symmetric arround pi/4</span>

                temp = Exx;
                logic = Eyy&gt;Exx;
                Exx(logic)=Eyy(logic);
                Eyy(logic) =temp(logic);
                <span class="comment">%</span>
                <span class="comment">% min(thetaArray)</span>
                <span class="comment">% max(thetaArray)</span>
                <span class="comment">% thetaArray=((pi/4)^2+thetaArray.^2).^(1/2);</span>
                <span class="comment">%                 temp2 = theta;</span>
                logic1 = theta&lt;0;
                theta(logic1) = -theta(logic1);
                logic2 = theta&gt;pi/4;
                logic3 = theta&lt;pi/4;
                theta(logic2)=theta(logic2)-pi/4;
                theta(logic3)=pi/4-theta(logic3);


                Exx=Exx*matProp.E_material1;
                Eyy=Eyy*matProp.E_material1;

                [t1,t2]=size(Exx);

                Exx=reshape(Exx,1,[]);
                Eyy=reshape(Eyy,1,[]);
                theta=reshape(theta,1,[]);

                X=[Exx;Eyy;theta];

                <span class="keyword">if</span>(config.UseLookUpTableForPsuedoStrain==1)
                    <span class="keyword">if</span> config.mesoDesignInitalConditions==3
                        <span class="comment">%                         [rhoValue,~,~] = annOutput_LookUpTable(X,[],[]);</span>
                        [rhoValue,~,~] = annOutput_lookupTable_withFmincon(X,[],[]);
                    <span class="keyword">elseif</span>(config.mesoDesignInitalConditions==1)
                        [rhoValue,~,~] = annOutput_RandomMesoInitialLookUpTable(X,[],[]);
                    <span class="keyword">end</span>
                <span class="keyword">else</span>
                    <span class="keyword">if</span>(config.mesoVolumeUpdateMethod==2)
                        [rhoValue,~,~] = annOutput_matUpdateV2(X,[],[]);
                    <span class="keyword">else</span>
                        [rhoValue,~,~] = annOutput_matUpdateV1(X,[],[]);
                    <span class="keyword">end</span>
                <span class="keyword">end</span>

                deltaT=1;
                XCopy = X;
                XCopy(1,:)=XCopy(1,:)+deltaT;

                <span class="keyword">if</span>(config.UseLookUpTableForPsuedoStrain==1)
                    <span class="keyword">if</span> config.mesoDesignInitalConditions==3
                        <span class="comment">%                         [rhoValue,~,~] = annOutput_LookUpTable(XCopy,[],[]);</span>
                        [rhoValue,~,~] = annOutput_lookupTable_withFmincon(XCopy,[],[]);
                    <span class="keyword">elseif</span>(config.mesoDesignInitalConditions==1)
                        [rhoValue,~,~] = annOutput_RandomMesoInitialLookUpTable(XCopy,[],[]);
                    <span class="keyword">end</span>
                <span class="keyword">else</span>
                    <span class="keyword">if</span>(config.mesoVolumeUpdateMethod==2)
                        [rhoValueXShift,~,~] = annOutput_matUpdateV2(XCopy,[],[]);
                    <span class="keyword">else</span>
                        [rhoValueXShift,~,~] = annOutput_matUpdateV1(XCopy,[],[]);

                    <span class="keyword">end</span>
                <span class="keyword">end</span>

                ExxSensitivity=(rhoValueXShift-rhoValue)/deltaT;

                XCopy = X;
                XCopy(2,:)=XCopy(2,:)+deltaT;

                <span class="keyword">if</span>(config.UseLookUpTableForPsuedoStrain==1)
                    <span class="keyword">if</span> config.mesoDesignInitalConditions==3
                        <span class="comment">%                         [rhoValue,~,~] = annOutput_LookUpTable(XCopy,[],[]);</span>
                        [rhoValue,~,~] = annOutput_lookupTable_withFmincon(XCopy,[],[]);
                    <span class="keyword">elseif</span>(config.mesoDesignInitalConditions==1)
                        [rhoValue,~,~] = annOutput_RandomMesoInitialLookUpTable(XCopy,[],[]);
                    <span class="keyword">end</span>
                <span class="keyword">else</span>
                    <span class="keyword">if</span>(config.mesoVolumeUpdateMethod==2)
                        [rhoValueYShift,~,~] = annOutput_matUpdateV2(XCopy,[],[]);
                    <span class="keyword">else</span>
                        [rhoValueYShift,~,~] = annOutput_matUpdateV1(XCopy,[],[]);
                    <span class="keyword">end</span>
                <span class="keyword">end</span>

                EyySensitivty=(rhoValueYShift-rhoValue)/deltaT;

                <span class="comment">% REshape to the orginal shape</span>
                rhoValue=reshape(rhoValue,t1,t2);
                scaleUpValue=1000;
                ExxSensitivity=reshape(ExxSensitivity,t1,t2)*scaleUpValue;
                EyySensitivty=reshape(EyySensitivty,t1,t2)*scaleUpValue;

                rhoValue(rhoValue&gt;1)=1;
                rhoValue(rhoValue&lt;0)=0;

                <span class="comment">%                 ExxSensitivity(ExxSensitivity&lt;0)=0.000001;</span>
                <span class="comment">%                 EyySensitivty(EyySensitivty&lt;0)=0.000001;</span>

            <span class="keyword">else</span>
                <span class="keyword">if</span>(config.useThetaInSurfaceFit==1)

                    <span class="comment">% make it so that Exx is always larger</span>
                    temp1=Eyy;
                    valueConditionTrue = Eyy&gt;Exx;
                    Eyy(valueConditionTrue)=Exx(valueConditionTrue);
                    Exx(valueConditionTrue)=temp1(valueConditionTrue);
                    <span class="comment">%                 if(Eyy&gt;Exx)</span>
                    <span class="comment">%                     Exx=Eyy;</span>
                    <span class="comment">%                     Eyy=Exx;</span>
                    <span class="comment">%                 end</span>
                    <span class="comment">% rhoValue= x(1)  + x(2)* exp(E_xx)  + x(3)* exp(E_yy)+x(4) *exp(theta) +x(5)*E_xx  + x(6)* E_yy +x(7)*theta+ x(8)*E_xx.*E_yy;</span>
                    <span class="comment">% ExxSensitivity=  x(2)* exp(E_xx)  +x(5) + x(8)*E_yy;</span>
                    <span class="comment">% EyySensitivty= x(3)* exp(E_yy) + x(6)+ x(8)*E_xx;</span>
                    rhoValue= co(1)+co(2)*Exx+co(3)*Eyy+co(4)*theta+co(5)*Exx.^2+co(6)* Eyy.^2+co(7)*theta.^2+co(8)*Exx.*Eyy+co(9)*Eyy.*theta+co(10)*Exx.*theta;
                    ExxSensitivity =co(2)+2*co(5)*Exx+co(8)*Eyy+co(10)*theta;
                    EyySensitivty = co(3)+2*co(6)* Eyy+co(8)*Exx+co(9)*theta;

                    <span class="comment">% Scale Up</span>
                    <span class="comment">%                 rhoValue=rhoValue*scaleUp;</span>
                    <span class="comment">%                 ExxSensitivity=ExxSensitivity*scaleUp;</span>
                    <span class="comment">%                 EyySensitivty=EyySensitivty*scaleUp;</span>
                    <span class="comment">%                 rhoValue(rhoValue&gt;1)=1;</span>
                    <span class="comment">%                 rhoValue(rhoValue&lt;0)=1;</span>
                <span class="keyword">else</span>
                    <span class="comment">% obj. ResponseSurfaceCoefficents=[ 1.0000000000463e-05 9.99988184437107e-06 9.9998491550433e-06 -3.40115537230351e-11 -5.52110060132392e-12 -3.81038581303971e-11];</span>
                    <span class="keyword">if</span>(config.useAnnForDensityNotDerivative==1)
                        minAllowed = 0.01;
                        x = ExxOriginal;
                        y = EyyOriginal;
                        <span class="comment">%                     rhoValue= co(1)  +  co(2) *x +  co(3) *y + co(4)*x^2 + co(5)*x*y + co(6)*y^2 + co(7)*x^3 + co(8)*x^2*y + co(9)*x*y^2 + co(10)*y^3;</span>

                        EyySensitivty= max(  co(3) *1 + co(5)*x*1 + 2*co(6)*y  + co(8)*x.^2*1 + 2*co(9)*x.*y +3* co(10)*y.^2,minAllowed);
                        ExxSensitivity=max( co(2) *1 +  2* co(4)*x + co(5)*1*y + 3*co(7)*x.^2 + 2*co(8)*x.*y + co(9)*1*y.^2 ,minAllowed);



                        temp = Exx;
                        logic = Eyy&gt;Exx;
                        Exx(logic)=Eyy(logic);
                        Eyy(logic) =temp(logic);
                        <span class="comment">%</span>
                        <span class="comment">% min(thetaArray)</span>
                        <span class="comment">% max(thetaArray)</span>
                        <span class="comment">% thetaArray=((pi/4)^2+thetaArray.^2).^(1/2);</span>
                        <span class="comment">%                 temp2 = theta;</span>
                        logic1 = theta&lt;0;
                        theta(logic1) = -theta(logic1);
                        logic2 = theta&gt;pi/4;
                        logic3 = theta&lt;pi/4;
                        theta(logic2)=theta(logic2)-pi/4;
                        theta(logic3)=pi/4-theta(logic3);


                        Exx=Exx*matProp.E_material1;
                        Eyy=Eyy*matProp.E_material1;

                        [t1,t2]=size(Exx);

                        Exx=reshape(Exx,1,[]);
                        Eyy=reshape(Eyy,1,[]);
                        theta=reshape(theta,1,[]);

                        X=[Exx;Eyy;theta];

                        <span class="keyword">if</span>(config.UseLookUpTableForPsuedoStrain==1)
                            <span class="keyword">if</span> config.mesoDesignInitalConditions==3
                                <span class="comment">%                                 [rhoValue,~,~] = annOutput_LookUpTable(X,[],[]);</span>
                                [rhoValue,~,~] = annOutput_lookupTable_withFmincon(X,[],[]);
                            <span class="keyword">elseif</span>(config.mesoDesignInitalConditions==1)
                                [rhoValue,~,~] = annOutput_RandomMesoInitialLookUpTable(X,[],[]);
                            <span class="keyword">end</span>
                        <span class="keyword">else</span>
                            <span class="keyword">if</span>(config.mesoVolumeUpdateMethod==2)
                                [rhoValue,~,~] = annOutput_matUpdateV2(X,[],[]);
                            <span class="keyword">else</span>
                                [rhoValue,~,~] = annOutput_matUpdateV1(X,[],[]);
                            <span class="keyword">end</span>
                        <span class="keyword">end</span>
                        rhoValue=reshape(rhoValue,t1,t2);


                        <span class="keyword">return</span>
                    <span class="keyword">end</span>
                    minAllowed = 0.01;
                    <span class="comment">% funciton from the values that I came up with as my</span>
                    <span class="comment">% first esimate of best fit.</span>
                    <span class="comment">%                     EyySensitivty=max(co(3)+co(5).*Exx+2*co(6).*Eyy,minAllowed);</span>
                    <span class="comment">%                     ExxSensitivity=max(co(2)+ 2*co(4).*Exx+co(5).*Eyy,minAllowed);</span>
                    <span class="comment">%                     rhoValue=   co(1) + co(2)*Exx + co(3)*Eyy + co(4)*Exx.^2 + co(5)*Exx.*Eyy + co(6)*Eyy.^2;</span>

                    x = ExxOriginal;
                    y = EyyOriginal;
                    rhoValue= co(1)  +  co(2) *x +  co(3) *y + co(4)*x^2 + co(5)*x*y + co(6)*y^2 + co(7)*x^3 + co(8)*x^2*y + co(9)*x*y^2 + co(10)*y^3;

                    EyySensitivty= max(  co(3) *1 + co(5)*x*1 + 2*co(6)*y  + co(8)*x^2*1 + 2*co(9)*x*y +3* co(10)*y^2,minAllowed);
                    ExxSensitivity=max( co(2) *1 +  2* co(4)*x + co(5)*1*y + 3*co(7)*x^2 + 2*co(8)*x*y + co(9)*1*y^2 ,minAllowed);
                <span class="keyword">end</span>
            <span class="keyword">end</span>

        <span class="keyword">end</span>

        <span class="comment">%         function [obj]=GenerateInterpolateANN(obj,Coefficents,config,matProp)</span>
        <span class="comment">%             if(config.useTargetMesoDensity==1)</span>
        <span class="comment">%</span>
        <span class="comment">%</span>
        <span class="comment">%                 outname = sprintf('./out%i/ANN_interp_E_xx.csv',0);</span>
        <span class="comment">%                 obj.ExxInterp=csvread(outname);</span>
        <span class="comment">%                 outname = sprintf('./out%i/ANN_interp_E_yy.csv',0);</span>
        <span class="comment">%                 obj.EyyInterp=csvread(outname);</span>
        <span class="comment">%                 outname = sprintf('./out%i/ANN_interp_Theta.csv',0);</span>
        <span class="comment">%                 obj.thetaInterp=csvread(outname);</span>
        <span class="comment">%                 outname = sprintf('./out%i/ANN_interp_Rho.csv',0);</span>
        <span class="comment">%                 obj.rhoInterp=csvread(outname);</span>
        <span class="comment">%</span>
        <span class="comment">%                 obj.ExxInterp=reshape(obj.ExxInterp,21,21,21);</span>
        <span class="comment">%                 obj.EyyInterp=reshape(obj.EyyInterp,21,21,21);</span>
        <span class="comment">%                 obj.thetaInterp=reshape(obj.thetaInterp,21,21,21);</span>
        <span class="comment">%                 obj.rhoInterp=reshape(obj.rhoInterp,21,21,21);</span>
        <span class="comment">%                 %                 valuesPerDir=15;</span>
        <span class="comment">%                 %                 ExxRange = 0:(matProp.E_material1)/valuesPerDir:matProp.E_material1;</span>
        <span class="comment">%                 %                 EyyRange=0:matProp.E_material1/valuesPerDir:matProp.E_material1;</span>
        <span class="comment">%                 %                 thetaRange = 0:(pi/2)/valuesPerDir:pi/2;</span>
        <span class="comment">%                 %</span>
        <span class="comment">%                 %                 [Exx,Eyy,theta] = ndgrid(ExxRange,EyyRange,thetaRange);</span>
        <span class="comment">%                 %                 % Needs to be reshaped</span>
        <span class="comment">%                 %                 [~, ~,rhoValue]= CalculateDensitySensitivityandRho_OLD(obj,Exx,Eyy,theta,Coefficents,config,matProp);</span>
        <span class="comment">%                 %</span>
        <span class="comment">%                 %                 obj.ExxInterp=Exx;</span>
        <span class="comment">%                 %                 obj.EyyInterp=Eyy;</span>
        <span class="comment">%                 %                 obj. thetaInterp=theta;</span>
        <span class="comment">%                 %                 obj.rhoInterp=rhoValue;</span>
        <span class="comment">%             end</span>
        <span class="comment">%</span>
        <span class="comment">%         end</span>
        <span class="comment">%</span>
        <span class="comment">%         %-----------------------------------</span>
        <span class="comment">%         % Meso Optimization</span>
        <span class="comment">%         %-----------------------------------</span>
        <span class="comment">%         function [DVmeso] = MesoDensityOptimization(~,mesoConfig, DVmeso,old_muMatrix,penaltyValue,macroElemProps)</span>
        <span class="comment">%             ne = mesoConfig.nelx*mesoConfig.nely; % number of elements</span>
        <span class="comment">%             %               dH_total=[DVmeso.d11;</span>
        <span class="comment">%             %                     DVmeso.d12;</span>
        <span class="comment">%             %                     DVmeso.d22;</span>
        <span class="comment">%             %                     DVmeso.d33];</span>
        <span class="comment">%             Diff_Sys_Sub =  (macroElemProps.D_subSys- macroElemProps.D_sys);</span>
        <span class="comment">%             localD = zeros(3,3);</span>
        <span class="comment">%             for e = 1:ne</span>
        <span class="comment">%</span>
        <span class="comment">%                 [x,y]= DVmeso.GivenNodeNumberGetXY(e);</span>
        <span class="comment">%                 xx=DVmeso.x(y,x); % =min(optimalEta, designVars.x+move)</span>
        <span class="comment">%                 %                  term1 = 10*xx^9;</span>
        <span class="comment">%                 %                  power = 1/4;</span>
        <span class="comment">%                 %                  term1 = power*xx^(power-1);</span>
        <span class="comment">%                 term1=2*xx;</span>
        <span class="comment">%</span>
        <span class="comment">%</span>
        <span class="comment">%</span>
        <span class="comment">%                 rowIndex = [1,1,2,3];</span>
        <span class="comment">%                 columnIndex = [1,2,2,3];</span>
        <span class="comment">%</span>
        <span class="comment">%                 dH = zeros(3,3);</span>
        <span class="comment">%                 dH(1,1) = DVmeso.d11(y,x);</span>
        <span class="comment">%                 dH(1,2) = DVmeso.d12(y,x);</span>
        <span class="comment">%                 dH(2,2) = DVmeso.d22(y,x);</span>
        <span class="comment">%                 dH(3,3) = DVmeso.d33(y,x);</span>
        <span class="comment">%</span>
        <span class="comment">%                 localD(1,1) = DVmeso.De11(y,x);</span>
        <span class="comment">%                 localD(1,2) = DVmeso.De11(y,x);</span>
        <span class="comment">%                 localD(2,2) = DVmeso.De11(y,x);</span>
        <span class="comment">%                 localD(3,3) = DVmeso.De11(y,x);</span>
        <span class="comment">%</span>
        <span class="comment">%                 Diff_Sys_Sub =  (localD- macroElemProps.D_sys);</span>
        <span class="comment">%</span>
        <span class="comment">%                 constraintCount = 0;</span>
        <span class="comment">%                 term2=0;</span>
        <span class="comment">%                 %                 term1=0;</span>
        <span class="comment">%                 for k = [1 2 3 ]</span>
        <span class="comment">%                     %                     term1=  dH(1,1)+  dH(1,2)+  dH(2,2)+  dH(3,3);</span>
        <span class="comment">%                     i = rowIndex(k);</span>
        <span class="comment">%                     j = columnIndex(k);</span>
        <span class="comment">%                     Ctemp = dH(i,j)*(-old_muMatrix(i,j)-penaltyValue*Diff_Sys_Sub(i,j));</span>
        <span class="comment">%                     term2 =term2 +Ctemp;</span>
        <span class="comment">%                     constraintCount=constraintCount+1;</span>
        <span class="comment">%                 end</span>
        <span class="comment">%</span>
        <span class="comment">%                 dL = term1+term2;</span>
        <span class="comment">%                 delta = 0.1;</span>
        <span class="comment">%                 optimalEta=xx+delta*dL;</span>
        <span class="comment">%                 move = 0.02;</span>
        <span class="comment">%                 DVmeso.x(y,x)=  max(0.01,max(xx-move,min(1.,min(xx+move,optimalEta))));</span>
        <span class="comment">%</span>
        <span class="comment">%                 DVmeso.x([10:13],[10:13])=1;</span>
        <span class="comment">%             end</span>
        <span class="comment">%         end</span>

        <span class="comment">% ----------------------------------</span>
        <span class="comment">% Optimize ANISOTROPIC Material</span>
        <span class="comment">%</span>
        <span class="comment">% TARGET AVG MESO DENSITY AS CONSTRAINT.</span>
        <span class="comment">% ----------------------------------</span>
        <span class="keyword">function</span> [DV] = OptimizeAnisotropicMaterial(obj,DV,config, matProp, masterloop)
            DV = DV.CalculateANISOTROPICSensitivity(config, matProp, masterloop);
            DV.sensitivityElastic = DV.check( config.nelx, config.nely,config.rminExxEyy,DV.x,DV.sensitivityElastic);
            DV.sensitivityElasticPart2 = DV.check( config.nelx, config.nely,config.rminExxEyy,DV.x,DV.sensitivityElasticPart2);
            DV.sensitivityElasticE12 = DV.check( config.nelx, config.nely,config.rminExxEyy,DV.x,DV.sensitivityElasticE12);
            DV.sensitivityElasticE33 = DV.check( config.nelx, config.nely,config.rminExxEyy,DV.x,DV.sensitivityElasticE33);


            <span class="comment">% if(config.macro_meso_iteration&gt;=2 &amp;&amp; mod(masterloop,3)==1)</span>
            <span class="keyword">if</span>(config.macro_meso_iteration&gt;=2 )
                deltaT=0.2;
                diffExx = DV.ExxSub-DV.Exx;
                diffEyy = DV.EyySub-DV.Eyy  ;
                <span class="comment">%</span>
                DV.lambdaExx=max( min(DV.lambdaExx+deltaT *diffExx,matProp.E_material1),-matProp.E_material1);
                DV.lambdaEyy= max( min( DV.lambdaEyy+deltaT*diffEyy,matProp.E_material1),-matProp.E_material1);
                <span class="comment">%  DV.lambdaExx=DV.lambdaExx+deltaT *diffExx;</span>
                <span class="comment">%   DV.lambdaEyy= DV.lambdaEyy+deltaT*diffEyy;</span>
                disp(<span class="string">'Updated Lambda Values Exx Eyy'</span>)
            <span class="keyword">end</span>


            <span class="comment">%-----------------------</span>
            <span class="comment">%</span>
            <span class="comment">% Update design var.</span>
            <span class="comment">%-----------------------</span>
            largest=1e8;

            E_target=config.targetAvgExxEyy;

            move = matProp.E_material1*0.05;
            minimum = matProp.E_material2*0.25;

            <span class="comment">% ----------------</span>
            <span class="comment">% Exx</span>
            <span class="comment">% ----------------</span>
            ExxNew = DV.Exx;
            EyyNew = DV.Eyy;
            E12New = DV.E12;
            E33New = DV.E33;

            totalMaterial = sum(sum(DV.x));

            term1Exx = DV.sensitivityElastic;
            term1Eyy= DV.sensitivityElasticPart2;
            term1E12 = DV.sensitivityElasticE12;
            term1E33= DV.sensitivityElasticE33;

            smallestLambdExx = min(min(DV.lambdaExx));
            smallestLambdEyy = min(min(DV.lambdaEyy));
            smallestOfTwo = min(smallestLambdExx,smallestLambdEyy);

            <span class="comment">% TODO !!!! Add term2 for E12 E 13</span>
            term2Exx =( DV.lambdaExx-smallestOfTwo).*DV.penaltyExx;
            term2Eyy = (DV.lambdaEyy-smallestOfTwo).*DV.penaltyEyy;

            w1 = 1;
            w2 = 0;
            <span class="comment">%    if( config.macro_meso_iteration&gt;=2 ) % Weight toward satifying consistency constraint.</span>
            <span class="comment">%    w2=min( ( config.macro_meso_iteration-2)*0.2,1); % staring iteration 3, start relaxing the meso density constraint.</span>
            <span class="comment">%      w1 = 1-w2;</span>
            <span class="comment">%     end</span>

            <span class="comment">%             theta = DV.t;</span>

            <span class="comment">% ---------------------------------------------------</span>
            <span class="comment">%</span>
            <span class="comment">% TARGET AVG MESO DENSITY AS CONSTRAINT.</span>
            <span class="comment">% Update 3 (idea)</span>
            <span class="comment">%</span>
            <span class="comment">% ---------------------------------------------------</span>
            l1 = 0; l2 = largest;<span class="comment">% move = 0.2;</span>
            sumDensity =0;
            theta=ExxNew*0;
            <span class="keyword">while</span> (l2-l1 &gt; 1e-5)
                lambda1 = 0.5*(l2+l1);
                <span class="comment">%                 ExxInput =ExxNew/matProp.E_material1; % % MOVED to the function scale down by the simp density, since the actual rho is a function of what is SIMP density and Exx or Eyy</span>
                <span class="comment">%                 EyyInput = EyyNew/matProp.E_material1;</span>
                <span class="comment">%                 [dDensityEyy, dDensityExx,~] = obj.CalculateDensitySensitivityandRho(ExxInput,EyyInput,theta,DV.x,DV.ResponseSurfaceCoefficents,config,matProp,DV.densityOffsetArray);</span>

                <span class="comment">% testing. Set equal to one for now.</span>
                dDensityExx=ones(size(term1Exx));
                dDensityEyy=ones(size(term1Exx));
                dDensityE12=ones(size(term1Exx));
                dDensityE33=ones(size(term1Exx));

                <span class="comment">% TODO !!!! Add term2 for E12 E 13</span>
                combinedTermsExx=(term1Exx+term2Exx)./(lambda1*dDensityExx);
                combinedTermsEyy=(term1Eyy+term2Eyy)./(lambda1*dDensityEyy);
                combinedTermsE12=(term1E12+term2Eyy)./(lambda1*dDensityE12);
                combinedTermsE33=(term1E33+term2Eyy)./(lambda1*dDensityE33);

                <span class="comment">%                 targetExx = ExxNew.*combinedTermsExx;</span>
                <span class="comment">%                 targetEyy = EyyNew.*combinedTermsEyy;</span>
                targetExx = DV.Exx.*combinedTermsExx;
                targetEyy = DV.Eyy.*combinedTermsEyy;
                targetE12 = DV.E12.*combinedTermsE12;
                targetE33 = DV.E33.*combinedTermsE33;

                ExxNew = max(0.1,max( minimum - EyyNew,  max(DV.Exx-move ,  min(  min(targetExx,DV.Exx+move ),matProp.E_material1))));
                EyyNew = max(0.1,max(minimum -  ExxNew,  max(DV.Eyy-move ,  min(  min(targetEyy,DV.Eyy+move ),matProp.E_material1))));

                E12New = max(0.1,max(DV.E12-move ,  min(  min(targetE12,DV.E12+move ),matProp.E_material1)));
                E33New = max(0.1, max(DV.E33-move ,  min(  min(targetE33,DV.E33+move ),matProp.E_material1)));

                <span class="comment">%                 sumDensity = sumDensity/(config.nelx*config.nely*config.totalVolume);</span>
                <span class="comment">% Determine if the consistency constraint is being under</span>
                <span class="comment">% valued</span>
                <span class="comment">% TODO, add consistency contraint for E12 and E33 values.</span>
                ExxSysAndSubDiffSummed=sum(sum(DV.x.*(ExxNew-DV.ExxSub))); <span class="comment">%</span>
                EyySysAndSubDiffSummed=sum(sum(DV.x.*(EyyNew-DV.EyySub)));<span class="comment">%</span>
                ConsistConstraintMag = ExxSysAndSubDiffSummed+EyySysAndSubDiffSummed;
                ConsistConstraintMag=-ConsistConstraintMag;
                ConsistConstraintMag = ConsistConstraintMag/(matProp.E_material1*totalMaterial);

                <span class="keyword">if</span>(config.useTargetMesoDensity==1)
                    [~, ~,rhoValue] = obj.CalculateDensitySensitivityandRho(ExxNew/matProp.E_material1,EyyNew/matProp.E_material1,theta,DV.x,DV.ResponseSurfaceCoefficents,config,matProp,DV.densityOffsetArray);
                    rhoValue=max(0,min(rhoValue,1));
                    temp2 = sum(sum(rhoValue));
                    sumDensity=temp2/(config.nelx*config.nely*config.totalVolume);
                    terms= w1*(config.targetExxEyyDensity- sumDensity)+w2*(ConsistConstraintMag);
                <span class="keyword">else</span>

                    totalExx =DV.x.*ExxNew;
                    totalEyy = DV.x.* EyyNew;
                    avgE = (totalExx+totalEyy)/2;
                    averageElasticLocal= sum(sum(avgE))/totalMaterial;
                    <span class="comment">%               averageElasticLocal = (sum(sum(EyyNew.*Xtemp))+sum(sum(ExxNew.*Xtemp)))/neSolid;</span>
                    <span class="comment">%               averageElasticLocal=averageElasticLocal/2; % Becuse Eyy and Exx are from one element, so to get the average divide by 2</span>
                    terms =  E_target- averageElasticLocal;

                <span class="keyword">end</span>


                <span class="keyword">if</span> (terms)&lt;0
                    l1 = lambda1;
                <span class="keyword">else</span>
                    l2 = lambda1;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            multiplier= 10000;
            text1 =    sprintf(<span class="string">'\nExxNew\t\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f'</span>,ExxNew(1,1) ,ExxNew(5,1),ExxNew(5,5));
            text2 =    sprintf(<span class="string">'ExxSub\t\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f'</span>,DV.ExxSub(1,1),DV.ExxSub(5,1),DV.ExxSub(5,5));
            text3=    sprintf(<span class="string">'Exx\\t\t\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f'</span>,DV.Exx(1,1),DV.Exx(5,1),DV.Exx(5,5));
            text4 =    sprintf(<span class="string">'DiffXXNew \t\t\t\t[1,1   5,1      5,5],  %f ,%f %f'</span>,ExxNew(1,1) - DV.ExxSub(1,1),ExxNew(5,1) - DV.ExxSub(5,1),ExxNew(5,5) - DV.ExxSub(5,5));
            text5 =    sprintf(<span class="string">'combinedTermsExx\t\t[1,1   5,1      5,5],  %f ,%f %f'</span>,combinedTermsExx(1,1),combinedTermsExx(5,1),combinedTermsExx(5,5));
            text6 =    sprintf(<span class="string">'penaltyExx*10000\t\t[1,1   5,1      5,5],  %f ,%f %f'</span>,DV.penaltyExx(1,1)*multiplier,DV.penaltyExx(5,1)*multiplier,DV.penaltyExx(5,5)*multiplier);
            text7 =    sprintf(<span class="string">'lambdaExx\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f'</span>,DV.lambdaExx(1,1),DV.lambdaExx(5,1),DV.lambdaExx(5,5));
            text75 =    sprintf(<span class="string">'dDensityExx\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f'</span>,dDensityExx(1,1),dDensityExx(5,1),dDensityExx(5,5));
            text8 =    sprintf(<span class="string">'lambda1 and density\t\t[  %f ,%f'</span>,lambda1,sumDensity);
            text9 =    sprintf(<span class="string">'ConsistConstraintMag and w2 \t\t[  %f ,%f\n'</span>,ConsistConstraintMag,w2);

            disp(text1)
            disp(text2)
            disp(text3)
            disp(text4)
            disp(text5)
            disp(text6)
            disp(text7)
            disp(text75)
            disp(text8)
            disp(text9)


            debug = 0;
            <span class="keyword">if</span>(debug ==1)
                figure(2)
                p = plotResults;
                xplots=3;
                yplots =3;
                plotNum=1;

                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(dDensityEyy,<span class="string">'dDensityEyy'</span>);
                plotNum=plotNum+1;

                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(dDensityExx,<span class="string">'dDensityExx'</span>);
                plotNum=plotNum+1;

                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(numeratorExx,<span class="string">'completeExx'</span>);
                plotNum=plotNum+1;

                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(numeratorEyy,<span class="string">'completeEyy'</span>);
                plotNum=plotNum+1;

                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(combinedTermsExx/lmid,<span class="string">'combinedTermsExx/lmid'</span>);
                plotNum=plotNum+1;

                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(combinedTermsEyy/lmid,<span class="string">'combinedTermsEyy/lmid'</span>);
                plotNum=plotNum+1;

                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(DV.t-DV.thetaSub,<span class="string">'theta diff'</span>);
                plotNum=plotNum+1;

                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(DV.Eyy - DV.EyySub,<span class="string">'Eyy diff'</span>);
                plotNum=plotNum+1;

                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(DV.Exx-DV.ExxSub,<span class="string">'Exx diff'</span>);
                plotNum=plotNum+1;
            <span class="keyword">end</span>

            <span class="comment">% -----------------------</span>
            <span class="comment">% Set the valeus.</span>
            <span class="comment">% -----------------------</span>
            DV.Exx =DV.Exx.*sqrt( ExxNew./  DV.Exx);
            DV.Eyy = DV.Eyy.*sqrt( EyyNew./  DV.Eyy );
            DV.E12 = DV.Eyy.*sqrt( E12New./  DV.E12 );
            DV.E33 = DV.E33.*sqrt( E33New./  DV.E33 );



        <span class="keyword">end</span>

                <span class="comment">% ----------------------------------</span>
        <span class="comment">% Version 2</span>
        <span class="comment">% ----------------------------------</span>
<span class="comment">%         function [DV] = OptimizeExxEyy_V2(obj,DV,config, matProp, masterloop)</span>
<span class="comment">%             DV = DV.CalculateExxEyySensitivity(config, matProp, masterloop);</span>
<span class="comment">%             DV.sensitivityElastic = DV.check( config.nelx, config.nely,config.rminExxEyy,DV.x,DV.sensitivityElastic);</span>
<span class="comment">%             DV.sensitivityElasticPart2 = DV.check( config.nelx, config.nely,config.rminExxEyy,DV.x,DV.sensitivityElasticPart2);</span>
<span class="comment">%</span>
<span class="comment">%             if(config.macro_meso_iteration&gt;=2 )</span>
<span class="comment">%                 deltaT=0.2;</span>
<span class="comment">%                 diffExx = DV.ExxSub-DV.Exx;</span>
<span class="comment">%                 diffEyy = DV.EyySub-DV.Eyy  ;</span>
<span class="comment">%                 %</span>
<span class="comment">%                 DV.lambdaExx=max( min(DV.lambdaExx+deltaT *diffExx,matProp.E_material1),-matProp.E_material1);</span>
<span class="comment">%                 DV.lambdaEyy= max( min( DV.lambdaEyy+deltaT*diffEyy,matProp.E_material1),-matProp.E_material1);</span>
<span class="comment">%                 %                   DV.lambdaExx=DV.lambdaExx+deltaT *diffExx;</span>
<span class="comment">%                 %                 DV.lambdaEyy= DV.lambdaEyy+deltaT*diffEyy;</span>
<span class="comment">%                 disp('Updated Lambda Values Exx Eyy')</span>
<span class="comment">%</span>
<span class="comment">%             end</span>
<span class="comment">%</span>
<span class="comment">%             %             if(config.testingVerGradMaterail ==1)</span>
<span class="comment">%             %                 avgSensitivy = 0.5*( DV.sensitivityElastic+  DV.sensitivityElasticPart2);</span>
<span class="comment">%             %                 DV.sensitivityElastic =avgSensitivy;</span>
<span class="comment">%             %                 DV.sensitivityElasticPart2 =avgSensitivy;</span>
<span class="comment">%             %             end</span>
<span class="comment">%</span>
<span class="comment">%             %-----------------------</span>
<span class="comment">%             %</span>
<span class="comment">%             % Update design var.</span>
<span class="comment">%             %-----------------------</span>
<span class="comment">%             largest=1e8;</span>
<span class="comment">%             move = matProp.E_material1*0.05;</span>
<span class="comment">%             minimum =config.minEallowed;</span>
<span class="comment">%</span>
<span class="comment">%             %              E_target =(config.v1*matProp.E_material1+config.v2*matProp.E_material2)/(config.v1+config.v2);</span>
<span class="comment">%             %             DV.targetAverageE = E_target;</span>
<span class="comment">%             E_target=config.targetAvgExxEyy;</span>
<span class="comment">%</span>
<span class="comment">%             % ----------------</span>
<span class="comment">%             % Exx</span>
<span class="comment">%             % ----------------</span>
<span class="comment">%             ExxNew = DV.Exx;</span>
<span class="comment">%             EyyNew = DV.Eyy;</span>
<span class="comment">%</span>
<span class="comment">%             totalMaterial = sum(sum(DV.x));</span>
<span class="comment">%</span>
<span class="comment">%             term1Exx = DV.sensitivityElastic;</span>
<span class="comment">%             term1Eyy= DV.sensitivityElasticPart2;</span>
<span class="comment">%</span>
<span class="comment">%             smallestLambdExx = min(min(DV.lambdaExx));</span>
<span class="comment">%             smallestLambdEyy = min(min(DV.lambdaEyy));</span>
<span class="comment">%             smallestOfTwo = min(smallestLambdExx,smallestLambdEyy);</span>
<span class="comment">%</span>
<span class="comment">%             term2Exx =( DV.lambdaExx-smallestOfTwo).*DV.penaltyExx;</span>
<span class="comment">%             term2Eyy = (DV.lambdaEyy-smallestOfTwo).*DV.penaltyEyy;</span>
<span class="comment">%</span>
<span class="comment">%             % ---------------------------------------------------</span>
<span class="comment">%             %</span>
<span class="comment">%             % TARGET AVG MESO DENSITY AS CONSTRAINT.</span>
<span class="comment">%             % Update 3 (idea)</span>
<span class="comment">%             %</span>
<span class="comment">%             % ---------------------------------------------------</span>
<span class="comment">%             l1 = 0; l2 = largest;% move = 0.2;</span>
<span class="comment">%             %             sumDensity =0;</span>
<span class="comment">%             while (l2-l1 &gt; 1e-4)</span>
<span class="comment">%                 lambda1 = 0.5*(l2+l1);</span>
<span class="comment">%                 %                 ExxInput =ExxNew/matProp.E_material1.*((DV.x).^config.penal); % scale down by the simp density, since the actual rho is a function of what is SIMP density and Exx or Eyy</span>
<span class="comment">%                 %                 EyyInput = EyyNew/matProp.E_material1.*((DV.x).^config.penal);</span>
<span class="comment">%                 %                 [dDensityEyy, dDensityExx,rhoValue] = obj.CalculateDensitySensitivityandRho(ExxInput,EyyInput,DV.t,DV.ResponseSurfaceCoefficents,config,matProp);</span>
<span class="comment">%                 % testing. Set equal to one for now.</span>
<span class="comment">%                 %                 dDensityExx=ones(size(term1Exx));</span>
<span class="comment">%                 %                 dDensityEyy=ones(size(term1Exx));</span>
<span class="comment">%                 combinedTermsExx=(term1Exx+term2Exx)./(lambda1*1);</span>
<span class="comment">%                 combinedTermsEyy=(term1Eyy+term2Eyy)./(lambda1*1);</span>
<span class="comment">%</span>
<span class="comment">%                 targetExx = DV.Exx.*combinedTermsExx;</span>
<span class="comment">%                 targetEyy = DV.Eyy.*combinedTermsEyy;</span>
<span class="comment">%                 ExxNew = max(0.1,max( minimum - EyyNew,  max(DV.Exx-move ,  min(  min(targetExx,DV.Exx+move ),matProp.E_material1))));</span>
<span class="comment">%                 EyyNew = max(0.1,max(minimum -  ExxNew,  max(DV.Eyy-move ,  min(  min(targetEyy,DV.Eyy+move ),matProp.E_material1))));</span>
<span class="comment">%</span>
<span class="comment">%                 %                 for i = 1:config.nelx</span>
<span class="comment">%                 %                     for j = 1:config.nely</span>
<span class="comment">%                 %                         % scale down the X and Y</span>
<span class="comment">%                 %                         x=ExxNew(j,i)/matProp.E_material1;</span>
<span class="comment">%                 %                         y=EyyNew(j,i)/matProp.E_material1;</span>
<span class="comment">%                 %                         theta=DV.t(j,i);</span>
<span class="comment">%                 %                         [~, ~,estimateElementDensity] = obj.CalculateDensitySensitivityandRho(x,y,theta,DV.ResponseSurfaceCoefficents,config,matProp);</span>
<span class="comment">%                 %</span>
<span class="comment">%                 %                         estimateElementDensity= min(max(estimateElementDensity,0.05),1);%1 is max, 0.5 is min</span>
<span class="comment">%                 %                         eleDensity = DV.x(j,i)*estimateElementDensity;</span>
<span class="comment">%                 %                         sumDensity =sumDensity+eleDensity;</span>
<span class="comment">%                 %</span>
<span class="comment">%                 %</span>
<span class="comment">%                 %                     end</span>
<span class="comment">%                 %                 end</span>
<span class="comment">%                 %                 sumDensity = sumDensity/(config.nelx*config.nely*config.totalVolume);</span>
<span class="comment">%</span>
<span class="comment">%                 totalExx =DV.x.*ExxNew;</span>
<span class="comment">%                 totalEyy = DV.x.* EyyNew;</span>
<span class="comment">%                 avgE = (totalExx+totalEyy)/2;</span>
<span class="comment">%                 averageElasticLocal= sum(sum(avgE))/totalMaterial;</span>
<span class="comment">%                 %               averageElasticLocal = (sum(sum(EyyNew.*Xtemp))+sum(sum(ExxNew.*Xtemp)))/neSolid;</span>
<span class="comment">%                 %               averageElasticLocal=averageElasticLocal/2; % Becuse Eyy and Exx are from one element, so to get the average divide by 2</span>
<span class="comment">%                 if E_target- averageElasticLocal&lt;0;</span>
<span class="comment">%                     l1 = lambda1;</span>
<span class="comment">%                 else</span>
<span class="comment">%                     l2 = lambda1;</span>
<span class="comment">%                 end</span>
<span class="comment">%             end</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%             text1 =    sprintf('\nExxNew\t\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f',ExxNew(1,1) ,ExxNew(5,1),ExxNew(5,5));</span>
<span class="comment">%             text2 =    sprintf('ExxSub\t\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f',DV.ExxSub(1,1),DV.ExxSub(5,1),DV.ExxSub(5,5));</span>
<span class="comment">%             text3=    sprintf('Exx\t\t\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f',DV.Exx(1,1),DV.Exx(5,1),DV.Exx(5,5));</span>
<span class="comment">%             text4=    sprintf('combinedTermsExx\t\t[1,1   5,1      5,5],  %f ,%f %f',combinedTermsExx(1,1),combinedTermsExx(5,1),combinedTermsExx(5,5));</span>
<span class="comment">%             text5 =    sprintf('DiffXX \t\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f',DV.Exx(1,1) - DV.ExxSub(1,1),DV.Exx(5,1) - DV.ExxSub(5,1),DV.Exx(5,5) - DV.ExxSub(5,5));</span>
<span class="comment">%             text6 =    sprintf('lambdaExx\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f',DV.lambdaExx(1,1),DV.lambdaExx(5,1),DV.lambdaExx(5,5));</span>
<span class="comment">%</span>
<span class="comment">%             text7 =    sprintf('Average E [Target, Current, Diff] \t\t\t%f\t%f\t%f', E_target,averageElasticLocal,E_target-averageElasticLocal);</span>
<span class="comment">%</span>
<span class="comment">%             disp(text1)</span>
<span class="comment">%             disp(text2)</span>
<span class="comment">%             disp(text3)</span>
<span class="comment">%             disp(text4)</span>
<span class="comment">%             disp(text5)</span>
<span class="comment">%             disp(text6)</span>
<span class="comment">%             disp(text7)</span>
<span class="comment">%</span>
<span class="comment">%             %             if(config.testingVerGradMaterail ==1)</span>
<span class="comment">%             %                 averageNewE = 0.5*(ExxNew+EyyNew);</span>
<span class="comment">%             %                 ExxNew=averageNewE;</span>
<span class="comment">%             %                 EyyNew=averageNewE;</span>
<span class="comment">%             %             end</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%             % -----------------------</span>
<span class="comment">%             % Set the valeus.</span>
<span class="comment">%             % -----------------------</span>
<span class="comment">%             DV.Exx =DV.Exx.*sqrt( ExxNew./  DV.Exx);</span>
<span class="comment">%</span>
<span class="comment">%             DV.Eyy = DV.Eyy.*sqrt( EyyNew./  DV.Eyy );</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%         end</span>
<span class="comment">%</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><pre class="codeoutput">
ans = 

  Optimizer with no properties.

</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017a</a><br></p></div><!--
##### SOURCE BEGIN #####
classdef Optimizer
    % Optimizer - class contains only the code that actually optimizes.
    %
    
    properties
%         ExxInterp=1;
%         EyyInterp=1;
%         thetaInterp=1;
%         rhoInterp=1;
    end
    
    methods
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
        % TOPOOLOGY, SIMP METHOD
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
        function DV = OptimizeTopology(obj,DV, config, matProp,masterloop)
            DV = DV.CalculateTopologySensitivity(config, matProp, masterloop);
            % normalize the sensitivies  by dividing by their max values.
            if (config.w1 ~= 1) % if we are using the heat objective
                temp1Max =-1* min(min(DV.sensitivityElastic));
                DV.sensitivityElastic = DV.sensitivityElastic/temp1Max;
                temp2Max = -1* min(min(DV.sensitivityHeat));
                DV.sensitivityHeat = DV.sensitivityHeat/temp2Max;
                DV.dc =1000* (config.w1*DV.sensitivityElastic+config.w2*DV.sensitivityHeat); % add the two sensitivies together using their weights
            else
                DV.dc = config.w1*DV.sensitivityElastic;
            end
            
          
            
            % FILTERING OF SENSITIVITIES
            [DV.dc]   = DV.check( config.nelx, config.nely,config.rmin,DV.x,DV.dc);
            % DESIGN UPDATE BY THE OPTIMALITY CRITERIA METHOD
            moveLimit=0.1;
            [DV.x]    = OC( config.nelx, config.nely,DV.x,config.totalVolume,DV.dc, DV, config,moveLimit);
            
            DV.x=DV.ApplyLoadSpecificEmptyRegions(config,DV.x);
         
        end
        
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        % VOLUME FRACTION OPTIMIZATION
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        function DV = OptimizeVolumeFraction(obj,DV,config, matProp, masterloop)
            DV = DV.CalculateMaterialGradientSensitivity(config, matProp, masterloop);
            
            DV =  DV.CalculateVolumeFractions(config,matProp);
            
            totalVolLocal = DV.currentVol1Fraction+ DV.currentVol2Fraction;
            fractionCurrent_V1Local = DV.currentVol1Fraction/totalVolLocal;
            targetFraction_v1 = config.v1/(config.v1+config.v2);
            
            % Normalize the sensitives.
            if (config.w1 ~= 1) % if we are using the heat objective
                temp1Max = max(max(abs(DV.sensitivityElastic)));
                DV.sensitivityElastic = DV.sensitivityElastic/temp1Max;
                temp2Max = max(max(abs(DV.sensitivityHeat)));
                DV.sensitivityHeat = DV.sensitivityHeat/temp2Max;
                
                g1 = config.w1*DV.sensitivityElastic+config.w2*DV.sensitivityHeat; % Calculate the weighted volume fraction change sensitivity.
            else
                g1 = config.w1*DV.sensitivityElastic;
            end
            
            % Filter the g1 sensitivies
            [g1]   = DV.check( config.nelx, config.nely,config.rmin,DV.x,g1);
            
            if(config.volFractionOptiizationMethod==1)
                G1 = g1 - DV.lambda1 +1/(DV.mu1)*( targetFraction_v1-fractionCurrent_V1Local); % add in the lagrangian
                DV.w = DV.w+config.timestep*G1; % update the volume fraction.
                DV.w = max(min( DV.w,1),0);    % Don't allow the    vol fraction to go above 1 or below 0
                DV.lambda1 =  DV.lambda1 -1/(DV.mu1)*(targetFraction_v1-fractionCurrent_V1Local)*config.volFractionDamping;
%                 DV.lambda1
            else
                largest=1e9;
                l1 = 0; l2 = largest;% move = 0.2;
                %             sumDensity =0;
                totalMaterial = sum(sum(DV.x));
                wProposed = DV.w;
                g1Max = max(max(g1));
                g1Min = min(min(g1));
                %                 if(g1Max>0)
                %                 g1=g1-g1Max;
                %                 end
                if(g1Min<0)
                    g1 = -g1Min+g1;
                end
                moveLimit = 0.1;
                
                targetRatioMethod =1;
                
              
                   targetRatio = config.v1/config.v2;
                
                while (l2-l1 > 1e-4)
                    lambda1 = 0.5*(l2+l1);
                    %                     wProposed=min(max(max(0,min(1,DV.w.*(sqrt(-g1Min+g1/lambda1)))),DV.w-moveLimit),DV.w+moveLimit);
                    wProposed=min(max(max(0,min(1,DV.w.*(sqrt(g1/lambda1)))),DV.w-moveLimit),DV.w+moveLimit);
                    
                    %                   totalMat1 =sum(sum( DV.x.*DV.w*matProp.E_material1));
                    %                 totalMat2 =sum(sum( DV.x.*(1-DV.w)*matProp.E_material2));
                    % obj.actualAverageE= obj.currentVol1Fraction*matProp.E_material1+  obj. currentVol2Fraction*matProp.E_material2;
                    %                 obj.actualAverageE= (totalMat1+totalMat2)/totalMaterial;
                  
                    %                 obj.   currentVol2Fraction =sum(sum( obj.x.*(1-obj.w)))/ne;
                    %                     fractionCurrent_V1Local = currentVol1Fraction/totalVolLocal;
                    
                    
                    if(1==0)      
                         currentVol1Fraction =sum(sum( DV.x.*wProposed))/totalMaterial;
                        if(targetRatioMethod==1)
                             % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
                            % Target ratio v1/(v1+v2))
                            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
                             
                            if targetFraction_v1- currentVol1Fraction<0
                                l1 = lambda1;                               
                            else
                                l2 = lambda1;                              
                            end
                        elseif(  targetRatioMethod==2)
                             % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
                            % Target ratio v1/v2
                            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
                            
                            currentV1 = sum(sum( DV.x.*wProposed));
                            currentV2 = sum(sum((DV.x).*(1-wProposed)));
                            currentRatio = currentV1/currentV2;
                             if 100*targetRatio- 100*currentRatio<0;
                                l1 = lambda1;
                                %                          l2 = lambda1;
                            else
                                l2 = lambda1;
                                %                          l1 = lambda1;
                             end
                            
                        elseif(  targetRatioMethod==3)
                            
                            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
                            % Target v1 only
                            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
%                               totalMaterial = sum(sum(DV.x));
                            
                            currentV1 = sum(sum( DV.x.*wProposed));
                          
                            v1RatioToTotal=currentV1/(config.nelx*config.nely);
                            
                            targetRatio=   config.v1;
                           
                             if targetRatio- v1RatioToTotal<0;
                                l1 = lambda1;
                                %                          l2 = lambda1;
                            else
                                l2 = lambda1;
                                %                          l1 = lambda1;
                             end
                            
                        end
                        
                        
                        
                    else
                        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
                        % Target an Elastic Modulus
                        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
                        totalMat1 =sum(sum( DV.x.*wProposed*matProp.E_material1));
                        totalMat2 =sum(sum( DV.x.*(1-wProposed)*matProp.E_material2));
                        % obj.actualAverageE= obj.currentVol1Fraction*matProp.E_material1+  obj. currentVol2Fraction*matProp.E_material2;
                        averageElasticLocal= (totalMat1+totalMat2)/totalMaterial;
                        %               averageElasticLocal = (sum(sum(EyyNew.*Xtemp))+sum(sum(ExxNew.*Xtemp)))/neSolid;
                        %               averageElasticLocal=averageElasticLocal/2; % Becuse Eyy and Exx are from one element, so to get the average divide by 2
                        E_target=config.targetAvgExxEyy;
                        if E_target- averageElasticLocal<0
                            l1 = lambda1;
                        else
                            l2 = lambda1;
                        end
                    end
                end
                DV.w=wProposed;
            end
        end
        
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        % ORTHO DISTRIBUTION OPTIMIZATION
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        %         function [] = OptimizeOrthoDistribution(obj,DV,config, matProp, masterloop)
        %             DV = DV.CalculateOthogonalDistributionSensitivity(config, matProp, masterloop);
        %             DV.sensitivityElastic = check( config.nelx, config.nely,config.rmin,DV.x,DV.sensitivityElastic);
        %             % move= 0.1* 20/(20+masterloop);
        %             move = config.orthDistMoveLimit;
        %             config.orthDistMoveLimit= config.orthDistMoveLimit* 10/(10+masterloop);
        %             %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
        %             %
        %             % Update design var.
        %             %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
        %             for ely = 1:config.nely
        %                 for elx = 1:config.nelx
        %                     if(DV.sensitivityElastic(ely,elx)<0.05)
        %                         DV.d(ely,elx) =  max(  DV.d(ely,elx)-move,config.minDorth);
        %                     end
        %
        %                     if(DV.sensitivityElastic(ely,elx)>0.05)
        %                         DV.d(ely,elx) =  min(  DV.d(ely,elx)+ move,config.maxDorth);
        %                     end
        %
        %                 end
        %             end
        %         end
        
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        % ROTATION OPTIMIZATION
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        function DV = OptimizeRotation(obj,DV,config, matProp, masterloop)
            %                 move= 0.1* 20/(20+masterloop);
            % allow multiple loading cases.
            [~, t2] = size(config.loadingCase);
            
            epsilon = pi/180; % 1 DEGREES ACCURACY
            elementsInRow = config.nelx+1;
            
            for ely = 1:config.nely
                rowMultiplier = ely-1;
                for elx = 1:config.nelx
                    rhoSIMP =  DV.x(ely,elx);
                    if(rhoSIMP>config.noNewMesoDesignDensityCutOff)
                        
                        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
                        % STEP 1, GET THE DISPLACEMENT FOR THIS NODE
                        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
                        nodes1=[rowMultiplier*elementsInRow+elx;
                            rowMultiplier*elementsInRow+elx+1;
                            (rowMultiplier +1)*elementsInRow+elx+1;
                            (rowMultiplier +1)*elementsInRow+elx];
                        
                        xNodes = nodes1*2-1;
                        yNodes = nodes1*2;
                        NodeNumbers = [xNodes(1) yNodes(1) xNodes(2) yNodes(2) xNodes(3) yNodes(3) xNodes(4) yNodes(4)];
                        UallCaseForElement = DV.U(1:t2,NodeNumbers);
                        U = UallCaseForElement;
                        
                        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
                        % STEP 2, SET UP GOLDEN RATIO METHOD TO FIND
                        % OPTIMAL THETA FOR ROTATION
                        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
                        
                        n = 0;
                        x0 = config.minRotation; %lower_bracket;
                        x3 = config.maxRotation;% higher_bracket;
                        leng = x3-x0;
                        grleng = leng*config.gr ; % golden ratio lenth
                        x1 = x3 - grleng;
                        x2 = x0 + grleng;
                        rhoSIMP =  DV.x(ely,elx);
                        mat1Frac  =[];% DV.w(ely,elx);
                        Exx = DV.Exx(ely,elx);
                        Eyy = DV.Eyy(ely,elx);
                        
                        thetaSubSystem = DV.thetaSub(ely,elx);
                        penaltyValue=DV.penaltyTheta(ely,elx);
                        lagraMultiplier=DV.lambdaTheta(ely,elx);
                        
                        %                         orthD = DV.d(ely,elx);
                        %fx1 = obj.EvaluteARotation(U,rhoSIMP, mat1Frac,Exx,Eyy,x1,thetaSubSystem,penaltyValue,lagraMultiplier,matProp, config,DV.maxElemStraniEnergy);
                        
                        
                        fx1= obj.EvaluteARotation(U,rhoSIMP, mat1Frac,Exx,Eyy,x1,thetaSubSystem,penaltyValue,lagraMultiplier,matProp, config,DV.maxElemStraniEnergy);
                        fx2 = obj.EvaluteARotation(U,rhoSIMP, mat1Frac,Exx,Eyy,x2,thetaSubSystem,penaltyValue,lagraMultiplier,matProp, config,DV.maxElemStraniEnergy);
                        
                        %                         if(masterloop>5)
                        %                             debug = 1;
                        %                         else
                        debug=0;
                        %                         end
                        verbosity = 0;
                        
                        if(   debug == 1)
                            xtemp = x0:pi/180:x3;
                            ytemp = zeros(1, size(xtemp,2));
                            count = 1;
                            for thetaTemp = xtemp
                                ytemp(count)= obj.EvaluteARotation(U,rhoSIMP, mat1Frac,Exx,Eyy,thetaTemp,thetaSubSystem,penaltyValue,lagraMultiplier,matProp, config,DV.maxElemStraniEnergy);
                                count = count+1;
                            end
                            figure(2)
                            subSysXvalus = [x0 DV.thetaSub(ely,elx) x3];
                            subSysYvalus = [min(ytemp) max(ytemp) max(ytemp)];
                            plot(xtemp,ytemp);
                            hold on
                            stairs(subSysXvalus,subSysYvalus)
                            hold off
                            title(sprintf('Lagrangian Function for Element x = %i, y = %i',elx,ely));
                            nothin = 1;
                        end
                        
                        
                        while(1 == 1)
                            if(debug == 1 && verbosity ==1)
                                str = sprintf('loop# = %d, x0 = %f, x1 = %f, x2 = %f, x3 = %f, fx1 = %f, fx2 = %f\n', n, x0, x1, x2, x3, fx1, fx2); display(str);
                            end
                            
                            if(fx1<=fx2) % less than or equal
                                % x0 = x0; % x0 stays the same
                                x3 = x2; % the old x2 is now x3
                                x2 = x1; % the old x1 is now x2
                                fx2 = fx1;
                                leng = x3 - x0; % find the length of the interval
                                x1 = x3 - leng*config.gr; % find golden ratio of length, subtract it from the x3 value
                                fx1 = obj.EvaluteARotation(U,rhoSIMP, mat1Frac,Exx,Eyy,x1,thetaSubSystem,penaltyValue,lagraMultiplier,matProp, config,DV.maxElemStraniEnergy);% calculate the fx
                                
                            elseif(fx1>fx2) % greater than
                                x0 = x1; % the old x1 is now x0
                                x1 = x2; % the old x2 is now the new x1
                                fx1 = fx2;
                                % x3 = x3; % x3 stays the same.
                                
                                leng = (x3 - x0); % find the length of the interval
                                x2 = x0 + leng*config.gr; % find golden ratio of length, subtract it from the x3 value
                                fx2 = obj.EvaluteARotation(U,rhoSIMP, mat1Frac,Exx,Eyy,x2,thetaSubSystem,penaltyValue,lagraMultiplier,matProp, config,DV.maxElemStraniEnergy);  % calculate the fx
                            end
                            
                            % check to see if we are as close as we want
                            if(leng < epsilon || n>100)
                                break;
                            end
                            n = n +1; % increment
                            
                        end
                        
                        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
                        % STEP 3, RECORD THE OPTIMAL THETA
                        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
                        minTvalue = (x2 + x3)/2;
                        moveLimit = config.rotationMoveLimit;
                        
                        % max move limit =  half the diff to optimal
                        diffT = abs(minTvalue-DV.t(ely,elx));
                        moveLimit=min(moveLimit,diffT*0.1);
                        
                        tOld = DV.t(ely,elx);
                        if(minTvalue>DV.t(ely,elx)+moveLimit)
                            DV.t(ely,elx)= DV.t(ely,elx)+moveLimit;
                        elseif(minTvalue<DV.t(ely,elx)-moveLimit)
                            DV.t(ely,elx)= DV.t(ely,elx)-moveLimit;
                        else
                            DV.t(ely,elx)=minTvalue;
                        end
                        
                        % Damp the changes
                        if(tOld>0 &&   DV.t(ely,elx) >0)
                            DV.t(ely,elx) = tOld*sqrt( DV.t(ely,elx)/tOld);
                        end
                    end
                end
            end
        end
        
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
        % EVALUTE THE OBJECTIVE FUNCTION FOR A ROTATION
        %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        function lagrangianValue = EvaluteARotation(~,U,topDensity, material1Fraction,Exx,Eyy,thetaSys,thetaSubSystem,penaltyValue,lagraMultiplier,matProp, config,maxElemStraniEnergy)
            K = matProp.getKMatrixTopExxYyyRotVars(config,topDensity,Exx, Eyy,thetaSys,material1Fraction, 1, 1);
            % LOOP OVER LOADING CASES.
            % U'S ROWS ARE UNIQUE LOADING CASES
            % EACH ROW CONTAINS 8 VALUES FOR THE 8 DOF OF THE ELEMENT
            % allow multiple loading cases.
            [~, t2] = size(config.loadingCase);
            term1=0;
            for i = 1:t2
                Ucase = U(i,:)';
                term1= term1+Ucase'*K*Ucase;
            end
            term1=-term1;
            %             term1=-term1/maxElemStraniEnergy;
            
            %             term2 = penaltyValue/2*(thetaSys-thetaSubSystem)^2;
            %             term2 = penaltyValue*(thetaSys-thetaSubSystem)^2;
            term2 = penaltyValue*abs(thetaSys-thetaSubSystem);
            %             term3 = lagraMultiplier*(thetaSys-thetaSubSystem);
            %             lagrangianValue=term1+term2+term3;
            %             normalizer=penaltyValue/2*(pi/4)^2;
            %                term2=term2/normalizer;
            
            %                lagrangianValue=term1+term2+term3;
            lagrangianValue=term1+term2;
            
            
        end
        
        
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        % E_xx and E_yy  OPTIMIZATION
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        function [DV] = OptimizeExxEyy(obj,DV,config, matProp, masterloop)
            %             if(config.useTargetMesoDensity==1)
            DV= OptimizeExxEyy_V3(obj,DV,config, matProp, masterloop);
            %             else
            %                 DV= OptimizeExxEyy_V2(obj,DV,config, matProp, masterloop);
            %             end
        end
        

        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        % E_xx and E_yy  OPTIMIZATION
        %
        %   Version 3
        % TARGET AVG MESO DENSITY AS CONSTRAINT.
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        function [DV] = OptimizeExxEyy_V3(obj,DV,config, matProp, masterloop)
            DV = DV.CalculateExxEyySensitivity(config, matProp, masterloop);
            DV.sensitivityElastic = DV.check( config.nelx, config.nely,config.rminExxEyy,DV.x,DV.sensitivityElastic);
            DV.sensitivityElasticPart2 = DV.check( config.nelx, config.nely,config.rminExxEyy,DV.x,DV.sensitivityElasticPart2);
            
            
            testingIsoTropicRecution=1;
            if(testingIsoTropicRecution==1)
                combinedSensitivity = DV.sensitivityElastic+ DV.sensitivityElasticPart2;
                 DV.sensitivityElasticPart2=combinedSensitivity;
                 DV.sensitivityElastic=combinedSensitivity;
            end
            
            % if(config.macro_meso_iteration>=2 && mod(masterloop,3)==1)
            if(config.macro_meso_iteration>=2 )
                deltaT=0.2;
                diffExx = DV.ExxSub-DV.Exx;
                diffEyy = DV.EyySub-DV.Eyy  ;
                %
                DV.lambdaExx=max( min(DV.lambdaExx+deltaT *diffExx,matProp.E_material1),-matProp.E_material1);
                DV.lambdaEyy= max( min( DV.lambdaEyy+deltaT*diffEyy,matProp.E_material1),-matProp.E_material1);
                %  DV.lambdaExx=DV.lambdaExx+deltaT *diffExx;
                %   DV.lambdaEyy= DV.lambdaEyy+deltaT*diffEyy;
                disp('Updated Lambda Values Exx Eyy')
            end
            
            
            %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            %
            % Update design var.
            %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            largest=1e9;
            
            move = matProp.E_material1*0.05;
            minimum =config.minEallowed;
            
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            % Exx
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            ExxNew = DV.Exx;
            EyyNew = DV.Eyy;
            
            totalMaterial = sum(sum(DV.x));
            
            term1Exx = DV.sensitivityElastic;
            term1Eyy= DV.sensitivityElasticPart2;
            
            smallestLambdExx = min(min(DV.lambdaExx));
            smallestLambdEyy = min(min(DV.lambdaEyy));
            smallestOfTwo = min(smallestLambdExx,smallestLambdEyy)-1;
            
            term2Exx =( DV.lambdaExx-smallestOfTwo).*DV.penaltyExx;
            term2Eyy = (DV.lambdaEyy-smallestOfTwo).*DV.penaltyEyy;
            
            w1 = 1;
            w2 = 0;
            %    if( config.macro_meso_iteration>=2 ) % Weight toward satifying consistency constraint.
            %    w2=min( ( config.macro_meso_iteration-2)*0.2,1); % staring iteration 3, start relaxing the meso density constraint.
            %      w1 = 1-w2;
            %     end
            
            theta = DV.t;
            
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            %
            % TARGET AVG MESO DENSITY AS CONSTRAINT.
            % Update 3 (idea)
            %
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            l1 = 0; l2 = largest;% move = 0.2;
            sumDensity =0;
            while (l2-l1 > 1e-5)
                lambda1 = 0.5*(l2+l1);
                
                if(config.useTargetMesoDensity==1)
                    ExxInput =ExxNew/matProp.E_material1; % % MOVED to the function scale down by the simp density, since the actual rho is a function of what is SIMP density and Exx or Eyy
                    EyyInput = EyyNew/matProp.E_material1;
                    [dDensityEyy, dDensityExx,~] = obj.CalculateDensitySensitivityandRho(ExxInput,EyyInput,theta,DV.x,DV.ResponseSurfaceCoefficents,config,matProp,DV.densityOffsetArray);
                    
                    dDensityEyy = DV.check( config.nelx, config.nely,config.rminExxEyy,DV.x,dDensityEyy);
                    dDensityExx = DV.check( config.nelx, config.nely,config.rminExxEyy,DV.x,dDensityExx);
                else
                    dDensityExx=ones(size(term1Exx));
                    dDensityEyy=ones(size(term1Exx));
                end
                
                
                
                
                combinedTermsExx=(term1Exx+term2Exx)./(lambda1*dDensityExx);
                combinedTermsEyy=(term1Eyy+term2Eyy)./(lambda1*dDensityEyy);
                
                %                 targetExx = ExxNew.*combinedTermsExx;
                %                 targetEyy = EyyNew.*combinedTermsEyy;
                targetExx = DV.Exx.*combinedTermsExx;
                targetEyy = DV.Eyy.*combinedTermsEyy;
                ExxNew = max(0.1,max( minimum - EyyNew,  max(DV.Exx-move ,  min(  min(targetExx,DV.Exx+move ),matProp.E_material1))));
                EyyNew = max(0.1,max(minimum -  ExxNew,  max(DV.Eyy-move ,  min(  min(targetEyy,DV.Eyy+move ),matProp.E_material1))));
                %                  logicTest1 = mesoDensity<config.minMesoDensityInOptimizer;
                %                   logicTest2 =DV.x>config.voidMaterialDensityCutOff;
                %                  logicTest=(logicTest1+logicTest2)>1.1;
                %                  minE_allowed = ones(size(targetExx));
                %                  minE_allowed(logicTest)=ExxNew(logicTest);
                %                  ExxNew = max(minE_allowed,max( minimum - EyyNew,  max(DV.Exx-move ,  min(  min(targetExx,DV.Exx+move ),matProp.E_material1))));
                %
                %                   minE_allowed(logicTest)=EyyNew(logicTest);
                %                 EyyNew = max(minE_allowed,max(minimum -  ExxNew,  max(DV.Eyy-move ,  min(  min(targetEyy,DV.Eyy+move ),matProp.E_material1))));
                
                %                 sumDensity = sumDensity/(config.nelx*config.nely*config.totalVolume);
                ExxSysAndSubDiffSummed=sum(sum(abs(DV.x.*(ExxNew-DV.ExxSub)))); %
                EyySysAndSubDiffSummed=sum(sum(abs(DV.x.*(EyyNew-DV.EyySub))));%
                ConsistConstraintMag = ExxSysAndSubDiffSummed+EyySysAndSubDiffSummed;
                %                 ConsistConstraintMag=-ConsistConstraintMag;
                ConsistConstraintMag = ConsistConstraintMag/(matProp.E_material1*totalMaterial);
                
                if(config.useTargetMesoDensity==1)
                    [~, ~,rhoValue] = obj.CalculateDensitySensitivityandRho(ExxNew/matProp.E_material1,EyyNew/matProp.E_material1,theta,DV.x,DV.ResponseSurfaceCoefficents,config,matProp,DV.densityOffsetArray);
                    rhoValue=max(0,min(rhoValue,1));
                    temp2 = sum(sum(rhoValue));
                    sumDensity=temp2/(config.nelx*config.nely*config.totalVolume);
                    
                    % Determine if the consistency constraint is being under
                    % valued
                    
                    
                    terms= w1*(config.targetExxEyyDensity- sumDensity)+w2*(ConsistConstraintMag);
                    if (terms)<0
                        l1 = lambda1;
                    else
                        l2 = lambda1;
                    end
                    
                else
                    totalExx =DV.x.*ExxNew;
                    totalEyy = DV.x.* EyyNew;
                    avgE = (totalExx+totalEyy)/2;
                    averageElasticLocal= sum(sum(avgE))/totalMaterial;
                    %               averageElasticLocal = (sum(sum(EyyNew.*Xtemp))+sum(sum(ExxNew.*Xtemp)))/neSolid;
                    %               averageElasticLocal=averageElasticLocal/2; % Becuse Eyy and Exx are from one element, so to get the average divide by 2
                    E_target=config.targetAvgExxEyy;
                    if E_target- averageElasticLocal<0;
                        l1 = lambda1;
                    else
                        l2 = lambda1;
                    end
                end
            end
            multiplier= 10000;
            text1 =    sprintf('\nExxNew\t\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f',ExxNew(1,1) ,ExxNew(5,1),ExxNew(5,5));
            text2 =    sprintf('ExxSub\t\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f',DV.ExxSub(1,1),DV.ExxSub(5,1),DV.ExxSub(5,5));
            text3=    sprintf('Exx\\t\t\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f',DV.Exx(1,1),DV.Exx(5,1),DV.Exx(5,5));
            text4 =    sprintf('DiffXXNew \t\t\t\t[1,1   5,1      5,5],  %f ,%f %f',ExxNew(1,1) - DV.ExxSub(1,1),ExxNew(5,1) - DV.ExxSub(5,1),ExxNew(5,5) - DV.ExxSub(5,5));
            text5 =    sprintf('combinedTermsExx\t\t[1,1   5,1      5,5],  %f ,%f %f',combinedTermsExx(1,1),combinedTermsExx(5,1),combinedTermsExx(5,5));
            text6 =    sprintf('penaltyExx*10000\t\t[1,1   5,1      5,5],  %f ,%f %f',DV.penaltyExx(1,1)*multiplier,DV.penaltyExx(5,1)*multiplier,DV.penaltyExx(5,5)*multiplier);
            text7 =    sprintf('lambdaExx\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f',DV.lambdaExx(1,1),DV.lambdaExx(5,1),DV.lambdaExx(5,5));
            text75 =    sprintf('dDensityExx\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f',dDensityExx(1,1),dDensityExx(5,1),dDensityExx(5,5));
            text8 =    sprintf('lambda1 and density\t\t[  %f ,%f',lambda1,sumDensity);
            text9 =    sprintf('ConsistConstraintMag and w2 \t\t[  %f ,%f\n',ConsistConstraintMag,w2);
            
            disp(text1)
            disp(text2)
            disp(text3)
            disp(text4)
            disp(text5)
            disp(text6)
            disp(text7)
            disp(text75)
            disp(text8)
            disp(text9)
            
            
            debug = 0;
            if(debug ==1)
                figure(2)
                p = plotResults;
                xplots=3;
                yplots =3;
                plotNum=1;
                
                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(dDensityEyy,'dDensityEyy');
                plotNum=plotNum+1;
                
                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(dDensityExx,'dDensityExx');
                plotNum=plotNum+1;
                
                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(numeratorExx,'completeExx');
                plotNum=plotNum+1;
                
                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(numeratorEyy,'completeEyy');
                plotNum=plotNum+1;
                
                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(combinedTermsExx/lmid,'combinedTermsExx/lmid');
                plotNum=plotNum+1;
                
                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(combinedTermsEyy/lmid,'combinedTermsEyy/lmid');
                plotNum=plotNum+1;
                
                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(DV.t-DV.thetaSub,'theta diff');
                plotNum=plotNum+1;
                
                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(DV.Eyy - DV.EyySub,'Eyy diff');
                plotNum=plotNum+1;
                
                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(DV.Exx-DV.ExxSub,'Exx diff');
                plotNum=plotNum+1;
            end
            
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            % Set the valeus.
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            DV.Exx =DV.Exx.*sqrt( ExxNew./  DV.Exx);
            DV.Eyy = DV.Eyy.*sqrt( EyyNew./  DV.Eyy );
            
             if(testingIsoTropicRecution==1)
                  E_combined =( DV.Exx+DV.Eyy)./2;
                    DV.Exx =E_combined;
                    DV.Eyy =E_combined;
             end
            
            
        end
        
        
        function [DV] =FindStartingExxEyy_V3(obj,DV,config, matProp, masterloop)
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            %
            %   SCALE starting Exx Eyy values
            %
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            if(config.macro_meso_iteration==1 )
                if (49<config.mode && config.mode <100  )
                    l1 = 0; l2 = 100000;% move = 0.2;
                    %             sumDensity =0;
                    o=Optimizer;
                    if(config.useTargetMesoDensity==1)
                        target=config.targetExxEyyDensity;
                        theta=DV.t;
                    else
                        target=config.targetAvgExxEyy;
                        totalMaterial= sum(sum(DV.x));
                    end
                    
                    fprintf('try scaling the starting values\n');
                    
                    while (l2-l1 > 1e-6)
                        lambda1 = 0.5*(l2+l1);
                        ExxNew=DV.Exx*lambda1;
                        EyyNew=DV.Eyy*lambda1;
                        
                        if(config.useTargetMesoDensity==1)
                            [~, ~,rhoValue] = o.CalculateDensitySensitivityandRho(ExxNew/matProp.E_material1,EyyNew/matProp.E_material1,theta,DV.x,DV.ResponseSurfaceCoefficents,config,matProp,0);
                            rhoValue=max(0,min(rhoValue,1));
                            temp2 = sum(sum(rhoValue));
                            sumDensity=temp2/(config.nelx*config.nely*config.totalVolume);
                            currentValue=sumDensity;
                        else
                            
                            
                            totalExx =DV.x.*ExxNew;
                            totalEyy = DV.x.* EyyNew;
                            avgE = (totalExx+totalEyy)/2;
                            averageElasticLocal= sum(sum(avgE))/totalMaterial;
                            
                            currentValue=averageElasticLocal;
                        end
                        
                        
                        fprintf('Target %f and current %f\n',target,currentValue);
                        if target- currentValue<0;
                            l2 = lambda1;
                        else
                            l1 = lambda1;
                        end
                    end
                    
                    DV.Exx=    DV.Exx*lambda1;
                    DV.Eyy=      DV.Eyy*lambda1;
                    
                    fprintf('Final Lambda = %f with final value of %f\n',lambda1,currentValue);
                end
            end
            
        end
        
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
        % Calculate the density and sensitivity of the Exx,Eyy,theta
        % values.
        %
        % USe a response surface, ANN, or interpolation depending on
        % settings.
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
        function [EyySensitivty, ExxSensitivity,rhoValue] = CalculateDensitySensitivityandRho(obj,Exx,Eyy,theta,xSimp,Coefficents,config,matProp,OffSet)
            
            [EyySensitivty, ExxSensitivity,rhoValue] = CalculateDensitySensitivityandRho_OLD(obj,Exx,Eyy,theta,xSimp,Coefficents,config,matProp);
            %               rhoValue=max(config.MesoMinimumDensity,min(rhoValue,1));
            rhoValue=rhoValue+OffSet;
        end
        
        function [EyySensitivty, ExxSensitivity,rhoValue] = CalculateDensitySensitivityandRho_OLD(obj,Exx,Eyy,theta,xSimp, Coefficents,config,matProp)
            co = Coefficents;
            
            
            
            Exx=Exx.*(xSimp.^config.penal);
            Eyy=Eyy.*(xSimp.^config.penal);
            
            ExxOriginal = Exx;
            EyyOriginal= Eyy;
            thetaOriginal = theta;
            
            if(config.useANN==1)
                
                % Make the inputs be so taht Exx > Eyy
                % Rather than a strict theta, use the distance from pi/4, since the problem
                % is symmetric arround pi/4
                
                temp = Exx;
                logic = Eyy>Exx;
                Exx(logic)=Eyy(logic);
                Eyy(logic) =temp(logic);
                %
                % min(thetaArray)
                % max(thetaArray)
                % thetaArray=((pi/4)^2+thetaArray.^2).^(1/2);
                %                 temp2 = theta;
                logic1 = theta<0;
                theta(logic1) = -theta(logic1);
                logic2 = theta>pi/4;
                logic3 = theta<pi/4;
                theta(logic2)=theta(logic2)-pi/4;
                theta(logic3)=pi/4-theta(logic3);
                
                
                Exx=Exx*matProp.E_material1;
                Eyy=Eyy*matProp.E_material1;
                
                [t1,t2]=size(Exx);
                
                Exx=reshape(Exx,1,[]);
                Eyy=reshape(Eyy,1,[]);
                theta=reshape(theta,1,[]);
                
                X=[Exx;Eyy;theta];
                
                if(config.UseLookUpTableForPsuedoStrain==1)
                    if config.mesoDesignInitalConditions==3
                        %                         [rhoValue,~,~] = annOutput_LookUpTable(X,[],[]);
                        [rhoValue,~,~] = annOutput_lookupTable_withFmincon(X,[],[]);
                    elseif(config.mesoDesignInitalConditions==1)
                        [rhoValue,~,~] = annOutput_RandomMesoInitialLookUpTable(X,[],[]);
                    end
                else
                    if(config.mesoVolumeUpdateMethod==2)
                        [rhoValue,~,~] = annOutput_matUpdateV2(X,[],[]);
                    else
                        [rhoValue,~,~] = annOutput_matUpdateV1(X,[],[]);
                    end
                end
                
                deltaT=1;
                XCopy = X;
                XCopy(1,:)=XCopy(1,:)+deltaT;
                
                if(config.UseLookUpTableForPsuedoStrain==1)
                    if config.mesoDesignInitalConditions==3
                        %                         [rhoValue,~,~] = annOutput_LookUpTable(XCopy,[],[]);
                        [rhoValue,~,~] = annOutput_lookupTable_withFmincon(XCopy,[],[]);
                    elseif(config.mesoDesignInitalConditions==1)
                        [rhoValue,~,~] = annOutput_RandomMesoInitialLookUpTable(XCopy,[],[]);
                    end
                else
                    if(config.mesoVolumeUpdateMethod==2)
                        [rhoValueXShift,~,~] = annOutput_matUpdateV2(XCopy,[],[]);
                    else
                        [rhoValueXShift,~,~] = annOutput_matUpdateV1(XCopy,[],[]);
                        
                    end
                end
                
                ExxSensitivity=(rhoValueXShift-rhoValue)/deltaT;
                
                XCopy = X;
                XCopy(2,:)=XCopy(2,:)+deltaT;
                
                if(config.UseLookUpTableForPsuedoStrain==1)
                    if config.mesoDesignInitalConditions==3
                        %                         [rhoValue,~,~] = annOutput_LookUpTable(XCopy,[],[]);
                        [rhoValue,~,~] = annOutput_lookupTable_withFmincon(XCopy,[],[]);
                    elseif(config.mesoDesignInitalConditions==1)
                        [rhoValue,~,~] = annOutput_RandomMesoInitialLookUpTable(XCopy,[],[]);
                    end
                else
                    if(config.mesoVolumeUpdateMethod==2)
                        [rhoValueYShift,~,~] = annOutput_matUpdateV2(XCopy,[],[]);
                    else
                        [rhoValueYShift,~,~] = annOutput_matUpdateV1(XCopy,[],[]);
                    end
                end
                
                EyySensitivty=(rhoValueYShift-rhoValue)/deltaT;
                
                % REshape to the orginal shape
                rhoValue=reshape(rhoValue,t1,t2);
                scaleUpValue=1000;
                ExxSensitivity=reshape(ExxSensitivity,t1,t2)*scaleUpValue;
                EyySensitivty=reshape(EyySensitivty,t1,t2)*scaleUpValue;
                
                rhoValue(rhoValue>1)=1;
                rhoValue(rhoValue<0)=0;
                
                %                 ExxSensitivity(ExxSensitivity<0)=0.000001;
                %                 EyySensitivty(EyySensitivty<0)=0.000001;
                
            else
                if(config.useThetaInSurfaceFit==1)
                    
                    % make it so that Exx is always larger
                    temp1=Eyy;
                    valueConditionTrue = Eyy>Exx;
                    Eyy(valueConditionTrue)=Exx(valueConditionTrue);
                    Exx(valueConditionTrue)=temp1(valueConditionTrue);
                    %                 if(Eyy>Exx)
                    %                     Exx=Eyy;
                    %                     Eyy=Exx;
                    %                 end
                    % rhoValue= x(1)  + x(2)* exp(E_xx)  + x(3)* exp(E_yy)+x(4) *exp(theta) +x(5)*E_xx  + x(6)* E_yy +x(7)*theta+ x(8)*E_xx.*E_yy;
                    % ExxSensitivity=  x(2)* exp(E_xx)  +x(5) + x(8)*E_yy;
                    % EyySensitivty= x(3)* exp(E_yy) + x(6)+ x(8)*E_xx;
                    rhoValue= co(1)+co(2)*Exx+co(3)*Eyy+co(4)*theta+co(5)*Exx.^2+co(6)* Eyy.^2+co(7)*theta.^2+co(8)*Exx.*Eyy+co(9)*Eyy.*theta+co(10)*Exx.*theta;
                    ExxSensitivity =co(2)+2*co(5)*Exx+co(8)*Eyy+co(10)*theta;
                    EyySensitivty = co(3)+2*co(6)* Eyy+co(8)*Exx+co(9)*theta;
                    
                    % Scale Up
                    %                 rhoValue=rhoValue*scaleUp;
                    %                 ExxSensitivity=ExxSensitivity*scaleUp;
                    %                 EyySensitivty=EyySensitivty*scaleUp;
                    %                 rhoValue(rhoValue>1)=1;
                    %                 rhoValue(rhoValue<0)=1;
                else
                    % obj. ResponseSurfaceCoefficents=[ 1.0000000000463e-05 9.99988184437107e-06 9.9998491550433e-06 -3.40115537230351e-11 -5.52110060132392e-12 -3.81038581303971e-11];
                    if(config.useAnnForDensityNotDerivative==1)
                        minAllowed = 0.01;
                        x = ExxOriginal;
                        y = EyyOriginal;
                        %                     rhoValue= co(1)  +  co(2) *x +  co(3) *y + co(4)*x^2 + co(5)*x*y + co(6)*y^2 + co(7)*x^3 + co(8)*x^2*y + co(9)*x*y^2 + co(10)*y^3;
                        
                        EyySensitivty= max(  co(3) *1 + co(5)*x*1 + 2*co(6)*y  + co(8)*x.^2*1 + 2*co(9)*x.*y +3* co(10)*y.^2,minAllowed);
                        ExxSensitivity=max( co(2) *1 +  2* co(4)*x + co(5)*1*y + 3*co(7)*x.^2 + 2*co(8)*x.*y + co(9)*1*y.^2 ,minAllowed);
                        
                        
                        
                        temp = Exx;
                        logic = Eyy>Exx;
                        Exx(logic)=Eyy(logic);
                        Eyy(logic) =temp(logic);
                        %
                        % min(thetaArray)
                        % max(thetaArray)
                        % thetaArray=((pi/4)^2+thetaArray.^2).^(1/2);
                        %                 temp2 = theta;
                        logic1 = theta<0;
                        theta(logic1) = -theta(logic1);
                        logic2 = theta>pi/4;
                        logic3 = theta<pi/4;
                        theta(logic2)=theta(logic2)-pi/4;
                        theta(logic3)=pi/4-theta(logic3);
                        
                        
                        Exx=Exx*matProp.E_material1;
                        Eyy=Eyy*matProp.E_material1;
                        
                        [t1,t2]=size(Exx);
                        
                        Exx=reshape(Exx,1,[]);
                        Eyy=reshape(Eyy,1,[]);
                        theta=reshape(theta,1,[]);
                        
                        X=[Exx;Eyy;theta];
                        
                        if(config.UseLookUpTableForPsuedoStrain==1)
                            if config.mesoDesignInitalConditions==3
                                %                                 [rhoValue,~,~] = annOutput_LookUpTable(X,[],[]);
                                [rhoValue,~,~] = annOutput_lookupTable_withFmincon(X,[],[]);
                            elseif(config.mesoDesignInitalConditions==1)
                                [rhoValue,~,~] = annOutput_RandomMesoInitialLookUpTable(X,[],[]);
                            end
                        else
                            if(config.mesoVolumeUpdateMethod==2)
                                [rhoValue,~,~] = annOutput_matUpdateV2(X,[],[]);
                            else
                                [rhoValue,~,~] = annOutput_matUpdateV1(X,[],[]);
                            end
                        end
                        rhoValue=reshape(rhoValue,t1,t2);
                        
                        
                        return
                    end
                    minAllowed = 0.01;
                    % funciton from the values that I came up with as my
                    % first esimate of best fit.
                    %                     EyySensitivty=max(co(3)+co(5).*Exx+2*co(6).*Eyy,minAllowed);
                    %                     ExxSensitivity=max(co(2)+ 2*co(4).*Exx+co(5).*Eyy,minAllowed);
                    %                     rhoValue=   co(1) + co(2)*Exx + co(3)*Eyy + co(4)*Exx.^2 + co(5)*Exx.*Eyy + co(6)*Eyy.^2;
                    
                    x = ExxOriginal;
                    y = EyyOriginal;
                    rhoValue= co(1)  +  co(2) *x +  co(3) *y + co(4)*x^2 + co(5)*x*y + co(6)*y^2 + co(7)*x^3 + co(8)*x^2*y + co(9)*x*y^2 + co(10)*y^3;
                    
                    EyySensitivty= max(  co(3) *1 + co(5)*x*1 + 2*co(6)*y  + co(8)*x^2*1 + 2*co(9)*x*y +3* co(10)*y^2,minAllowed);
                    ExxSensitivity=max( co(2) *1 +  2* co(4)*x + co(5)*1*y + 3*co(7)*x^2 + 2*co(8)*x*y + co(9)*1*y^2 ,minAllowed);
                end
            end
            
        end
        
        %         function [obj]=GenerateInterpolateANN(obj,Coefficents,config,matProp)
        %             if(config.useTargetMesoDensity==1)
        %
        %
        %                 outname = sprintf('./out%i/ANN_interp_E_xx.csv',0);
        %                 obj.ExxInterp=csvread(outname);
        %                 outname = sprintf('./out%i/ANN_interp_E_yy.csv',0);
        %                 obj.EyyInterp=csvread(outname);
        %                 outname = sprintf('./out%i/ANN_interp_Theta.csv',0);
        %                 obj.thetaInterp=csvread(outname);
        %                 outname = sprintf('./out%i/ANN_interp_Rho.csv',0);
        %                 obj.rhoInterp=csvread(outname);
        %
        %                 obj.ExxInterp=reshape(obj.ExxInterp,21,21,21);
        %                 obj.EyyInterp=reshape(obj.EyyInterp,21,21,21);
        %                 obj.thetaInterp=reshape(obj.thetaInterp,21,21,21);
        %                 obj.rhoInterp=reshape(obj.rhoInterp,21,21,21);
        %                 %                 valuesPerDir=15;
        %                 %                 ExxRange = 0:(matProp.E_material1)/valuesPerDir:matProp.E_material1;
        %                 %                 EyyRange=0:matProp.E_material1/valuesPerDir:matProp.E_material1;
        %                 %                 thetaRange = 0:(pi/2)/valuesPerDir:pi/2;
        %                 %
        %                 %                 [Exx,Eyy,theta] = ndgrid(ExxRange,EyyRange,thetaRange);
        %                 %                 % Needs to be reshaped
        %                 %                 [~, ~,rhoValue]= CalculateDensitySensitivityandRho_OLD(obj,Exx,Eyy,theta,Coefficents,config,matProp);
        %                 %
        %                 %                 obj.ExxInterp=Exx;
        %                 %                 obj.EyyInterp=Eyy;
        %                 %                 obj. thetaInterp=theta;
        %                 %                 obj.rhoInterp=rhoValue;
        %             end
        %
        %         end
        %
        %         %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
        %         % Meso Optimization
        %         %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
        %         function [DVmeso] = MesoDensityOptimization(~,mesoConfig, DVmeso,old_muMatrix,penaltyValue,macroElemProps)
        %             ne = mesoConfig.nelx*mesoConfig.nely; % number of elements
        %             %               dH_total=[DVmeso.d11;
        %             %                     DVmeso.d12;
        %             %                     DVmeso.d22;
        %             %                     DVmeso.d33];
        %             Diff_Sys_Sub =  (macroElemProps.D_subSys- macroElemProps.D_sys);
        %             localD = zeros(3,3);
        %             for e = 1:ne
        %
        %                 [x,y]= DVmeso.GivenNodeNumberGetXY(e);
        %                 xx=DVmeso.x(y,x); % =min(optimalEta, designVars.x+move)
        %                 %                  term1 = 10*xx^9;
        %                 %                  power = 1/4;
        %                 %                  term1 = power*xx^(power-1);
        %                 term1=2*xx;
        %
        %
        %
        %                 rowIndex = [1,1,2,3];
        %                 columnIndex = [1,2,2,3];
        %
        %                 dH = zeros(3,3);
        %                 dH(1,1) = DVmeso.d11(y,x);
        %                 dH(1,2) = DVmeso.d12(y,x);
        %                 dH(2,2) = DVmeso.d22(y,x);
        %                 dH(3,3) = DVmeso.d33(y,x);
        %
        %                 localD(1,1) = DVmeso.De11(y,x);
        %                 localD(1,2) = DVmeso.De11(y,x);
        %                 localD(2,2) = DVmeso.De11(y,x);
        %                 localD(3,3) = DVmeso.De11(y,x);
        %
        %                 Diff_Sys_Sub =  (localD- macroElemProps.D_sys);
        %
        %                 constraintCount = 0;
        %                 term2=0;
        %                 %                 term1=0;
        %                 for k = [1 2 3 ]
        %                     %                     term1=  dH(1,1)+  dH(1,2)+  dH(2,2)+  dH(3,3);
        %                     i = rowIndex(k);
        %                     j = columnIndex(k);
        %                     Ctemp = dH(i,j)*(-old_muMatrix(i,j)-penaltyValue*Diff_Sys_Sub(i,j));
        %                     term2 =term2 +Ctemp;
        %                     constraintCount=constraintCount+1;
        %                 end
        %
        %                 dL = term1+term2;
        %                 delta = 0.1;
        %                 optimalEta=xx+delta*dL;
        %                 move = 0.02;
        %                 DVmeso.x(y,x)=  max(0.01,max(xx-move,min(1.,min(xx+move,optimalEta))));
        %
        %                 DVmeso.x([10:13],[10:13])=1;
        %             end
        %         end
        
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        % Optimize ANISOTROPIC Material
        %
        % TARGET AVG MESO DENSITY AS CONSTRAINT.
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        function [DV] = OptimizeAnisotropicMaterial(obj,DV,config, matProp, masterloop)
            DV = DV.CalculateANISOTROPICSensitivity(config, matProp, masterloop);
            DV.sensitivityElastic = DV.check( config.nelx, config.nely,config.rminExxEyy,DV.x,DV.sensitivityElastic);
            DV.sensitivityElasticPart2 = DV.check( config.nelx, config.nely,config.rminExxEyy,DV.x,DV.sensitivityElasticPart2);
            DV.sensitivityElasticE12 = DV.check( config.nelx, config.nely,config.rminExxEyy,DV.x,DV.sensitivityElasticE12);
            DV.sensitivityElasticE33 = DV.check( config.nelx, config.nely,config.rminExxEyy,DV.x,DV.sensitivityElasticE33);
            
            
            % if(config.macro_meso_iteration>=2 && mod(masterloop,3)==1)
            if(config.macro_meso_iteration>=2 )
                deltaT=0.2;
                diffExx = DV.ExxSub-DV.Exx;
                diffEyy = DV.EyySub-DV.Eyy  ;
                %
                DV.lambdaExx=max( min(DV.lambdaExx+deltaT *diffExx,matProp.E_material1),-matProp.E_material1);
                DV.lambdaEyy= max( min( DV.lambdaEyy+deltaT*diffEyy,matProp.E_material1),-matProp.E_material1);
                %  DV.lambdaExx=DV.lambdaExx+deltaT *diffExx;
                %   DV.lambdaEyy= DV.lambdaEyy+deltaT*diffEyy;
                disp('Updated Lambda Values Exx Eyy')
            end
            
            
            %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            %
            % Update design var.
            %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            largest=1e8;
            
            E_target=config.targetAvgExxEyy;
            
            move = matProp.E_material1*0.05;
            minimum = matProp.E_material2*0.25;
            
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            % Exx
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            ExxNew = DV.Exx;
            EyyNew = DV.Eyy;
            E12New = DV.E12;
            E33New = DV.E33;
            
            totalMaterial = sum(sum(DV.x));
            
            term1Exx = DV.sensitivityElastic;
            term1Eyy= DV.sensitivityElasticPart2;
            term1E12 = DV.sensitivityElasticE12;
            term1E33= DV.sensitivityElasticE33;
            
            smallestLambdExx = min(min(DV.lambdaExx));
            smallestLambdEyy = min(min(DV.lambdaEyy));
            smallestOfTwo = min(smallestLambdExx,smallestLambdEyy);
            
            % TODO !!!! Add term2 for E12 E 13
            term2Exx =( DV.lambdaExx-smallestOfTwo).*DV.penaltyExx;
            term2Eyy = (DV.lambdaEyy-smallestOfTwo).*DV.penaltyEyy;
            
            w1 = 1;
            w2 = 0;
            %    if( config.macro_meso_iteration>=2 ) % Weight toward satifying consistency constraint.
            %    w2=min( ( config.macro_meso_iteration-2)*0.2,1); % staring iteration 3, start relaxing the meso density constraint.
            %      w1 = 1-w2;
            %     end
            
            %             theta = DV.t;
            
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            %
            % TARGET AVG MESO DENSITY AS CONSTRAINT.
            % Update 3 (idea)
            %
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            l1 = 0; l2 = largest;% move = 0.2;
            sumDensity =0;
            theta=ExxNew*0;
            while (l2-l1 > 1e-5)
                lambda1 = 0.5*(l2+l1);
                %                 ExxInput =ExxNew/matProp.E_material1; % % MOVED to the function scale down by the simp density, since the actual rho is a function of what is SIMP density and Exx or Eyy
                %                 EyyInput = EyyNew/matProp.E_material1;
                %                 [dDensityEyy, dDensityExx,~] = obj.CalculateDensitySensitivityandRho(ExxInput,EyyInput,theta,DV.x,DV.ResponseSurfaceCoefficents,config,matProp,DV.densityOffsetArray);
                
                % testing. Set equal to one for now.
                dDensityExx=ones(size(term1Exx));
                dDensityEyy=ones(size(term1Exx));
                dDensityE12=ones(size(term1Exx));
                dDensityE33=ones(size(term1Exx));
                
                % TODO !!!! Add term2 for E12 E 13
                combinedTermsExx=(term1Exx+term2Exx)./(lambda1*dDensityExx);
                combinedTermsEyy=(term1Eyy+term2Eyy)./(lambda1*dDensityEyy);
                combinedTermsE12=(term1E12+term2Eyy)./(lambda1*dDensityE12);
                combinedTermsE33=(term1E33+term2Eyy)./(lambda1*dDensityE33);
                
                %                 targetExx = ExxNew.*combinedTermsExx;
                %                 targetEyy = EyyNew.*combinedTermsEyy;
                targetExx = DV.Exx.*combinedTermsExx;
                targetEyy = DV.Eyy.*combinedTermsEyy;
                targetE12 = DV.E12.*combinedTermsE12;
                targetE33 = DV.E33.*combinedTermsE33;
                
                ExxNew = max(0.1,max( minimum - EyyNew,  max(DV.Exx-move ,  min(  min(targetExx,DV.Exx+move ),matProp.E_material1))));
                EyyNew = max(0.1,max(minimum -  ExxNew,  max(DV.Eyy-move ,  min(  min(targetEyy,DV.Eyy+move ),matProp.E_material1))));
                
                E12New = max(0.1,max(DV.E12-move ,  min(  min(targetE12,DV.E12+move ),matProp.E_material1)));
                E33New = max(0.1, max(DV.E33-move ,  min(  min(targetE33,DV.E33+move ),matProp.E_material1)));
                
                %                 sumDensity = sumDensity/(config.nelx*config.nely*config.totalVolume);
                % Determine if the consistency constraint is being under
                % valued
                % TODO, add consistency contraint for E12 and E33 values.
                ExxSysAndSubDiffSummed=sum(sum(DV.x.*(ExxNew-DV.ExxSub))); %
                EyySysAndSubDiffSummed=sum(sum(DV.x.*(EyyNew-DV.EyySub)));%
                ConsistConstraintMag = ExxSysAndSubDiffSummed+EyySysAndSubDiffSummed;
                ConsistConstraintMag=-ConsistConstraintMag;
                ConsistConstraintMag = ConsistConstraintMag/(matProp.E_material1*totalMaterial);
                
                if(config.useTargetMesoDensity==1)
                    [~, ~,rhoValue] = obj.CalculateDensitySensitivityandRho(ExxNew/matProp.E_material1,EyyNew/matProp.E_material1,theta,DV.x,DV.ResponseSurfaceCoefficents,config,matProp,DV.densityOffsetArray);
                    rhoValue=max(0,min(rhoValue,1));
                    temp2 = sum(sum(rhoValue));
                    sumDensity=temp2/(config.nelx*config.nely*config.totalVolume);
                    terms= w1*(config.targetExxEyyDensity- sumDensity)+w2*(ConsistConstraintMag);
                else
                    
                    totalExx =DV.x.*ExxNew;
                    totalEyy = DV.x.* EyyNew;
                    avgE = (totalExx+totalEyy)/2;
                    averageElasticLocal= sum(sum(avgE))/totalMaterial;
                    %               averageElasticLocal = (sum(sum(EyyNew.*Xtemp))+sum(sum(ExxNew.*Xtemp)))/neSolid;
                    %               averageElasticLocal=averageElasticLocal/2; % Becuse Eyy and Exx are from one element, so to get the average divide by 2
                    terms =  E_target- averageElasticLocal;
                    
                end
                
                
                if (terms)<0
                    l1 = lambda1;
                else
                    l2 = lambda1;
                end
            end
            multiplier= 10000;
            text1 =    sprintf('\nExxNew\t\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f',ExxNew(1,1) ,ExxNew(5,1),ExxNew(5,5));
            text2 =    sprintf('ExxSub\t\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f',DV.ExxSub(1,1),DV.ExxSub(5,1),DV.ExxSub(5,5));
            text3=    sprintf('Exx\\t\t\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f',DV.Exx(1,1),DV.Exx(5,1),DV.Exx(5,5));
            text4 =    sprintf('DiffXXNew \t\t\t\t[1,1   5,1      5,5],  %f ,%f %f',ExxNew(1,1) - DV.ExxSub(1,1),ExxNew(5,1) - DV.ExxSub(5,1),ExxNew(5,5) - DV.ExxSub(5,5));
            text5 =    sprintf('combinedTermsExx\t\t[1,1   5,1      5,5],  %f ,%f %f',combinedTermsExx(1,1),combinedTermsExx(5,1),combinedTermsExx(5,5));
            text6 =    sprintf('penaltyExx*10000\t\t[1,1   5,1      5,5],  %f ,%f %f',DV.penaltyExx(1,1)*multiplier,DV.penaltyExx(5,1)*multiplier,DV.penaltyExx(5,5)*multiplier);
            text7 =    sprintf('lambdaExx\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f',DV.lambdaExx(1,1),DV.lambdaExx(5,1),DV.lambdaExx(5,5));
            text75 =    sprintf('dDensityExx\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f',dDensityExx(1,1),dDensityExx(5,1),dDensityExx(5,5));
            text8 =    sprintf('lambda1 and density\t\t[  %f ,%f',lambda1,sumDensity);
            text9 =    sprintf('ConsistConstraintMag and w2 \t\t[  %f ,%f\n',ConsistConstraintMag,w2);
            
            disp(text1)
            disp(text2)
            disp(text3)
            disp(text4)
            disp(text5)
            disp(text6)
            disp(text7)
            disp(text75)
            disp(text8)
            disp(text9)
            
            
            debug = 0;
            if(debug ==1)
                figure(2)
                p = plotResults;
                xplots=3;
                yplots =3;
                plotNum=1;
                
                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(dDensityEyy,'dDensityEyy');
                plotNum=plotNum+1;
                
                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(dDensityExx,'dDensityExx');
                plotNum=plotNum+1;
                
                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(numeratorExx,'completeExx');
                plotNum=plotNum+1;
                
                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(numeratorEyy,'completeEyy');
                plotNum=plotNum+1;
                
                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(combinedTermsExx/lmid,'combinedTermsExx/lmid');
                plotNum=plotNum+1;
                
                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(combinedTermsEyy/lmid,'combinedTermsEyy/lmid');
                plotNum=plotNum+1;
                
                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(DV.t-DV.thetaSub,'theta diff');
                plotNum=plotNum+1;
                
                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(DV.Eyy - DV.EyySub,'Eyy diff');
                plotNum=plotNum+1;
                
                subplot(xplots,yplots,plotNum);
                p. PlotArrayGeneric(DV.Exx-DV.ExxSub,'Exx diff');
                plotNum=plotNum+1;
            end
            
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            % Set the valeus.
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            DV.Exx =DV.Exx.*sqrt( ExxNew./  DV.Exx);
            DV.Eyy = DV.Eyy.*sqrt( EyyNew./  DV.Eyy );
            DV.E12 = DV.Eyy.*sqrt( E12New./  DV.E12 );
            DV.E33 = DV.E33.*sqrt( E33New./  DV.E33 );
            
            
            
        end
        
                % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        % Version 2
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
%         function [DV] = OptimizeExxEyy_V2(obj,DV,config, matProp, masterloop)
%             DV = DV.CalculateExxEyySensitivity(config, matProp, masterloop);
%             DV.sensitivityElastic = DV.check( config.nelx, config.nely,config.rminExxEyy,DV.x,DV.sensitivityElastic);
%             DV.sensitivityElasticPart2 = DV.check( config.nelx, config.nely,config.rminExxEyy,DV.x,DV.sensitivityElasticPart2);
%             
%             if(config.macro_meso_iteration>=2 )
%                 deltaT=0.2;
%                 diffExx = DV.ExxSub-DV.Exx;
%                 diffEyy = DV.EyySub-DV.Eyy  ;
%                 %
%                 DV.lambdaExx=max( min(DV.lambdaExx+deltaT *diffExx,matProp.E_material1),-matProp.E_material1);
%                 DV.lambdaEyy= max( min( DV.lambdaEyy+deltaT*diffEyy,matProp.E_material1),-matProp.E_material1);
%                 %                   DV.lambdaExx=DV.lambdaExx+deltaT *diffExx;
%                 %                 DV.lambdaEyy= DV.lambdaEyy+deltaT*diffEyy;
%                 disp('Updated Lambda Values Exx Eyy')
%                 
%             end
%             
%             %             if(config.testingVerGradMaterail ==1)
%             %                 avgSensitivy = 0.5*( DV.sensitivityElastic+  DV.sensitivityElasticPart2);
%             %                 DV.sensitivityElastic =avgSensitivy;
%             %                 DV.sensitivityElasticPart2 =avgSensitivy;
%             %             end
%             
%             %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%             %
%             % Update design var.
%             %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%             largest=1e8;
%             move = matProp.E_material1*0.05;
%             minimum =config.minEallowed;
%             
%             %              E_target =(config.v1*matProp.E_material1+config.v2*matProp.E_material2)/(config.v1+config.v2);
%             %             DV.targetAverageE = E_target;
%             E_target=config.targetAvgExxEyy;
%             
%             % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
%             % Exx
%             % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
%             ExxNew = DV.Exx;
%             EyyNew = DV.Eyy;
%             
%             totalMaterial = sum(sum(DV.x));
%             
%             term1Exx = DV.sensitivityElastic;
%             term1Eyy= DV.sensitivityElasticPart2;
%             
%             smallestLambdExx = min(min(DV.lambdaExx));
%             smallestLambdEyy = min(min(DV.lambdaEyy));
%             smallestOfTwo = min(smallestLambdExx,smallestLambdEyy);
%             
%             term2Exx =( DV.lambdaExx-smallestOfTwo).*DV.penaltyExx;
%             term2Eyy = (DV.lambdaEyy-smallestOfTwo).*DV.penaltyEyy;
%             
%             % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%             %
%             % TARGET AVG MESO DENSITY AS CONSTRAINT.
%             % Update 3 (idea)
%             %
%             % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%             l1 = 0; l2 = largest;% move = 0.2;
%             %             sumDensity =0;
%             while (l2-l1 > 1e-4)
%                 lambda1 = 0.5*(l2+l1);
%                 %                 ExxInput =ExxNew/matProp.E_material1.*((DV.x).^config.penal); % scale down by the simp density, since the actual rho is a function of what is SIMP density and Exx or Eyy
%                 %                 EyyInput = EyyNew/matProp.E_material1.*((DV.x).^config.penal);
%                 %                 [dDensityEyy, dDensityExx,rhoValue] = obj.CalculateDensitySensitivityandRho(ExxInput,EyyInput,DV.t,DV.ResponseSurfaceCoefficents,config,matProp);
%                 % testing. Set equal to one for now.
%                 %                 dDensityExx=ones(size(term1Exx));
%                 %                 dDensityEyy=ones(size(term1Exx));
%                 combinedTermsExx=(term1Exx+term2Exx)./(lambda1*1);
%                 combinedTermsEyy=(term1Eyy+term2Eyy)./(lambda1*1);
%                 
%                 targetExx = DV.Exx.*combinedTermsExx;
%                 targetEyy = DV.Eyy.*combinedTermsEyy;
%                 ExxNew = max(0.1,max( minimum - EyyNew,  max(DV.Exx-move ,  min(  min(targetExx,DV.Exx+move ),matProp.E_material1))));
%                 EyyNew = max(0.1,max(minimum -  ExxNew,  max(DV.Eyy-move ,  min(  min(targetEyy,DV.Eyy+move ),matProp.E_material1))));
%                 
%                 %                 for i = 1:config.nelx
%                 %                     for j = 1:config.nely
%                 %                         % scale down the X and Y
%                 %                         x=ExxNew(j,i)/matProp.E_material1;
%                 %                         y=EyyNew(j,i)/matProp.E_material1;
%                 %                         theta=DV.t(j,i);
%                 %                         [~, ~,estimateElementDensity] = obj.CalculateDensitySensitivityandRho(x,y,theta,DV.ResponseSurfaceCoefficents,config,matProp);
%                 %
%                 %                         estimateElementDensity= min(max(estimateElementDensity,0.05),1);%1 is max, 0.5 is min
%                 %                         eleDensity = DV.x(j,i)*estimateElementDensity;
%                 %                         sumDensity =sumDensity+eleDensity;
%                 %
%                 %
%                 %                     end
%                 %                 end
%                 %                 sumDensity = sumDensity/(config.nelx*config.nely*config.totalVolume);
%                 
%                 totalExx =DV.x.*ExxNew;
%                 totalEyy = DV.x.* EyyNew;
%                 avgE = (totalExx+totalEyy)/2;
%                 averageElasticLocal= sum(sum(avgE))/totalMaterial;
%                 %               averageElasticLocal = (sum(sum(EyyNew.*Xtemp))+sum(sum(ExxNew.*Xtemp)))/neSolid;
%                 %               averageElasticLocal=averageElasticLocal/2; % Becuse Eyy and Exx are from one element, so to get the average divide by 2
%                 if E_target- averageElasticLocal<0;
%                     l1 = lambda1;
%                 else
%                     l2 = lambda1;
%                 end
%             end
%             
%             
%             text1 =    sprintf('\nExxNew\t\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f',ExxNew(1,1) ,ExxNew(5,1),ExxNew(5,5));
%             text2 =    sprintf('ExxSub\t\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f',DV.ExxSub(1,1),DV.ExxSub(5,1),DV.ExxSub(5,5));
%             text3=    sprintf('Exx\t\t\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f',DV.Exx(1,1),DV.Exx(5,1),DV.Exx(5,5));
%             text4=    sprintf('combinedTermsExx\t\t[1,1   5,1      5,5],  %f ,%f %f',combinedTermsExx(1,1),combinedTermsExx(5,1),combinedTermsExx(5,5));
%             text5 =    sprintf('DiffXX \t\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f',DV.Exx(1,1) - DV.ExxSub(1,1),DV.Exx(5,1) - DV.ExxSub(5,1),DV.Exx(5,5) - DV.ExxSub(5,5));
%             text6 =    sprintf('lambdaExx\t\t\t\t[1,1   5,1      5,5],  %f ,%f %f',DV.lambdaExx(1,1),DV.lambdaExx(5,1),DV.lambdaExx(5,5));
%             
%             text7 =    sprintf('Average E [Target, Current, Diff] \t\t\t%f\t%f\t%f', E_target,averageElasticLocal,E_target-averageElasticLocal);
%             
%             disp(text1)
%             disp(text2)
%             disp(text3)
%             disp(text4)
%             disp(text5)
%             disp(text6)
%             disp(text7)
%             
%             %             if(config.testingVerGradMaterail ==1)
%             %                 averageNewE = 0.5*(ExxNew+EyyNew);
%             %                 ExxNew=averageNewE;
%             %                 EyyNew=averageNewE;
%             %             end
%             
%             
%             % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%             % Set the valeus.
%             % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%             DV.Exx =DV.Exx.*sqrt( ExxNew./  DV.Exx);
%             
%             DV.Eyy = DV.Eyy.*sqrt( EyyNew./  DV.Eyy );
%             
%             
%         end
%         
    end
end


##### SOURCE END #####
--></body></html>